<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html>
<head>
    <title>Voxel Space Game</title>
    <meta charset="UTF-8">
    <style>
        html, body {margin: 0; height: 100%; overflow: hidden}
        canvas { width: 100%; height: 100%; display: block; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
        }
        #healthbar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid white;
        }
        #health {
            width: 100%;
            height: 100%;
            background: #ff0000;
        }
        #info {
            position: absolute;
            top: 0px;
            left: 10px;
            padding: 5px;
            z-index: 100;
            color: white;
            font-family: "Arial", sans-serif;
            font-size: 16px;
        }
        #fps {
            position: absolute;
            top: 0px;
            right: 10px;
            padding: 5px;
            z-index: 100;
            color: white;
            font-family: "Arial", sans-serif;
            font-size: 16px;
        }
        #bulletcount, #lastbulletpos, #playerrotation, #playerposition {
            position: absolute;
            right: 10px;
            padding: 5px;
            z-index: 100;
            color: white;
            font-family: "Arial", sans-serif;
            font-size: 16px;
        }
        #bulletcount { bottom: 10px; }
        #playerposition { bottom: 35px; }
        #playerrotation { bottom: 60px; }
        #lastbulletpos { bottom: 85px; }
    </style>
</head>

<body>
<div id="crosshair"></div>
<div id="healthbar">
    <div id="health"></div>
</div>
<div id="fps"></div>
<div id="lastbulletpos"></div>
<div id="playerrotation"></div>
<div id="playerposition"></div>
<div id="bulletcount"></div>
<div id="info">
    Controls: WASD to move, Mouse to look, Left Click to shoot, Space to jump, Shift to sprint, C to crouch, R to reload
</div>

<canvas id="fullscreenCanvas" width="800" height="400">
    Your browser does not support the canvas element.
</canvas>

<script>
"use strict";

var camera = {
    x: 512,
    y: 800,
    height: 78,
    angle: 0,
    horizon: 100,
    distance: 800,
    velocityY: 0
};

var player = {
    health: 100,
    isCrouching: false,
    moveSpeed: 1.5,
    sprintMultiplier: 2,
    jumpStrength: 15,
    crouchHeight: 40,
    normalHeight: 78
};

var gun = {
    magazine: 20,
    maxMagazine: 20,
    reloadTime: 3000,
    isReloading: false,
    lastShot: 0,
    fireRate: 300
};

var bullets = [];
var lastBullet = null;

var map = {
    width: 1024,
    height: 1024,
    shift: 10,
    altitude: new Uint8Array(1024*1024),
    color: new Uint32Array(1024*1024)
};

var screendata = {
    canvas: null,
    context: null,
    imagedata: null,
    bufarray: null,
    buf8: null,
    buf32: null,
    backgroundcolor: 0xFFE09090
};

var input = {
    forward: false,
    backward: false,
    left: false,
    right: false,
    jump: false,
    sprint: false,
    crouch: false,
    shoot: false,
    reload: false,
    mouseX: 0,
    mouseY: 0
};

var updaterunning = false;
var time = new Date().getTime();
var timelastframe = new Date().getTime();
var frames = 0;

function UpdateCamera() {
    var current = new Date().getTime();
    var deltaTime = (current - time) * 0.03;

    // Movement
    let speed = player.moveSpeed * (input.sprint ? player.sprintMultiplier : 1) * deltaTime;
    if (input.forward) {
        camera.x -= Math.sin(camera.angle) * speed;
        camera.y -= Math.cos(camera.angle) * speed;
    }
    if (input.backward) {
        camera.x += Math.sin(camera.angle) * speed;
        camera.y += Math.cos(camera.angle) * speed;
    }
    if (input.left) {
        camera.x -= Math.cos(camera.angle) * speed;
        camera.y += Math.sin(camera.angle) * speed;
    }
    if (input.right) {
        camera.x += Math.cos(camera.angle) * speed;
        camera.y -= Math.sin(camera.angle) * speed;
    }

    // Apply gravity
    camera.velocityY -= 0.5 * deltaTime;
    camera.height += camera.velocityY * deltaTime;

    // Jumping
    if (input.jump && isOnGround()) {
        camera.velocityY = player.jumpStrength;
    }

    // Crouching
    if (input.crouch) {
        if (!player.isCrouching) {
            player.isCrouching = true;
            camera.height = player.crouchHeight;
        }
    } else if (player.isCrouching) {
        player.isCrouching = false;
        camera.height = player.normalHeight;
    }

    // Ground collision
    var mapoffset = ((Math.floor(camera.y) & (map.width-1)) << map.shift) + (Math.floor(camera.x) & (map.height-1))|0;
    var groundHeight = map.altitude[mapoffset] + 10;
    if (camera.height < groundHeight) {
        camera.height = groundHeight;
        camera.velocityY = 0;
        if (input.jump) {
            camera.velocityY = player.jumpStrength;
        }
    }

    // Shooting
    if (input.shoot && !gun.isReloading && gun.magazine > 0 && current - gun.lastShot > gun.fireRate) {
        var targetDistance = 100;
        var bulletSpeed = 20;
        // Calculate target point 100 units ahead
        var targetX = camera.x - Math.sin(camera.angle) * targetDistance;
        var targetY = camera.y - Math.cos(camera.angle) * targetDistance;
        var pitchAngle = (camera.horizon - 100) * Math.PI / 1080; // Reduced scaling for smoother vertical aim
        var targetZ = camera.height - Math.tan(pitchAngle) * targetDistance;
        // Calculate direction vector
        var dx = targetX - camera.x;
        var dy = targetY - camera.y;
        var dz = targetZ - camera.height;
        // Normalize direction vector
        var magnitude = Math.sqrt(dx*dx + dy*dy + dz*dz);
        dx = (dx / magnitude) * bulletSpeed;
        dy = (dy / magnitude) * bulletSpeed;
        dz = (dz / magnitude) * bulletSpeed;
        // Spawn bullet with offset to appear from bottom right
        var offsetX = Math.cos(camera.angle) * -2;
        var offsetY = Math.sin(camera.angle) * -2;
        var offsetZ = -2;
        lastBullet = {
            x: camera.x + offsetX,
            y: camera.y + offsetY,
            z: camera.height + offsetZ,
            dx: dx,
            dy: dy,
            dz: dz,
            distance: 0,
            spawnAngle: camera.angle
        };
        bullets.push(lastBullet);
        gun.magazine--;
        gun.lastShot = current;
    }

    // Reloading
    if (input.reload && !gun.isReloading && gun.magazine < gun.maxMagazine) {
        gun.isReloading = true;
        setTimeout(() => {
            gun.magazine = gun.maxMagazine;
            gun.isReloading = false;
        }, gun.reloadTime);
    }

    // Update bullets
    bullets = bullets.filter(bullet => {
        bullet.x += bullet.dx * deltaTime;
        bullet.y += bullet.dy * deltaTime;
        bullet.z += bullet.dz * deltaTime;
        bullet.distance += Math.sqrt(bullet.dx * bullet.dx + bullet.dy * bullet.dy + bullet.dz * bullet.dz) * deltaTime;

        // Terrain collision
        var bulletMapOffset = ((Math.floor(bullet.y) & (map.width-1)) << map.shift) + (Math.floor(bullet.x) & (map.height-1))|0;
        var terrainHeight = map.altitude[bulletMapOffset];
        if (bullet.z <= terrainHeight) {
            if (bullet === lastBullet) lastBullet = null;
            return false;
        }
        return bullet.distance < camera.distance;
    });

    // Update UI
    document.getElementById('health').style.width = player.health + '%';
    document.getElementById('bulletcount').innerText = `Ammo: ${gun.magazine}/${gun.maxMagazine}`;
    document.getElementById('playerposition').innerText = `Pos: (${camera.x.toFixed(1)}, ${camera.y.toFixed(1)}, ${camera.height.toFixed(1)})`;
    document.getElementById('playerrotation').innerText = `Rot: (${(camera.angle * 180 / Math.PI).toFixed(1)}Â°, ${camera.horizon.toFixed(1)})`;
    document.getElementById('lastbulletpos').innerText = lastBullet ? 
        `Bullet: (${lastBullet.x.toFixed(1)}, ${lastBullet.y.toFixed(1)}, ${lastBullet.z.toFixed(1)})` : 
        `Bullet: None`;

    time = current;
}

function isOnGround() {
    var mapoffset = ((Math.floor(camera.y) & (map.width-1)) << map.shift) + (Math.floor(camera.x) & (map.height-1))|0;
    return camera.height <= map.altitude[mapoffset] + 10 + 0.1;
}

function DetectKeysDown(e) {
    switch(e.keyCode) {
        case 87: // W
            input.forward = true;
            break;
        case 83: // S
            input.backward = true;
            break;
        case 65: // A
            input.left = true;
            break;
        case 68: // D
            input.right = true;
            break;
        case 32: // Space
            input.jump = true;
            break;
        case 16: // Shift
            input.sprint = true;
            break;
        case 67: // C
            input.crouch = true;
            break;
        case 82: // R
            input.reload = true;
            break;
    }
    if (!updaterunning) {
        time = new Date().getTime();
        Draw();
    }
}

function DetectKeysUp(e) {
    switch(e.keyCode) {
        case 87: // W
            input.forward = false;
            break;
        case 83: // S
            input.backward = false;
            break;
        case 65: // A
            input.left = false;
            break;
        case 68: // D
            input.right = false;
            break;
        case 32: // Space
            input.jump = false;
            break;
        case 16: // Shift
            input.sprint = false;
            break;
        case 67: // C
            input.crouch = false;
            break;
        case 82: // R
            input.reload = false;
            break;
    }
}

function DetectMouseDown(e) {
    if (e.button === 0) {
        input.shoot = true;
    }
}

function DetectMouseUp(e) {
    if (e.button === 0) {
        input.shoot = false;
    }
}

function DetectMouseMove(e) {
    camera.angle -= e.movementX * 0.002;
    camera.horizon -= e.movementY * 0.2;
    camera.horizon = Math.max(-200, Math.min(300, camera.horizon));
}

function DrawVerticalLine(x, ytop, ybottom, col) {
    x = x|0;
    ytop = ytop|0;
    ybottom = ybottom|0;
    col = col|0;
    var buf32 = screendata.buf32;
    var screenwidth = screendata.canvas.width|0;
    if (ytop < 0) ytop = 0;
    if (ytop > ybottom) return;

    var offset = ((ytop * screenwidth) + x)|0;
    for (var k = ytop|0; k < ybottom|0; k=k+1|0) {
        buf32[offset|0] = col|0;
        offset = offset + screenwidth|0;
    }
}

function DrawCircle(x, y, radius, col) {
    x = x|0;
    y = y|0;
    radius = radius|0;
    col = col|0;
    var buf32 = screendata.buf32;
    var screenwidth = screendata.canvas.width|0;
    var screenheight = screendata.canvas.height|0;

    for (var i = -radius; i <= radius; i++) {
        for (var j = -radius; j <= radius; j++) {
            if (i*i + j*j <= radius*radius) {
                var px = x + i;
                var py = y + j;
                if (px >= 0 && px < screenwidth && py >= 0 && py < screenheight) {
                    buf32[(py * screenwidth + px)|0] = col|0;
                }
            }
        }
    }
}

function DrawBackground() {
    var buf32 = screendata.buf32;
    var color = screendata.backgroundcolor|0;
    for (var i = 0; i < buf32.length; i++) buf32[i] = color|0;
}

function Flip() {
    screendata.imagedata.data.set(screendata.buf8);
    screendata.context.putImageData(screendata.imagedata, 0, 0);
}

function Render() {
    var mapwidthperiod = map.width - 1;
    var mapheightperiod = map.height - 1;
    var screenwidth = screendata.canvas.width|0;
    var screenheight = screendata.canvas.height|0;
    var sinang = Math.sin(camera.angle);
    var cosang = Math.cos(camera.angle);
    var hiddeny = new Int32Array(screenwidth);
    for(var i=0; i<screenwidth|0; i=i+1|0)
        hiddeny[i] = screendata.canvas.height;
    var deltaz = 1.;

    // Draw terrain
    for(var z=1; z<camera.distance; z+=deltaz) {
        var plx = -cosang * z - sinang * z;
        var ply = sinang * z - cosang * z;
        var prx = cosang * z - sinang * z;
        var pry = -sinang * z - cosang * z;
        var dx = (prx - plx) / screenwidth;
        var dy = (pry - ply) / screenwidth;
        plx += camera.x;
        ply += camera.y;
        var invz = 1. / z * 240.;
        for(var i=0; i<screenwidth|0; i=i+1|0) {
            var mapoffset = ((Math.floor(ply) & mapwidthperiod) << map.shift) + (Math.floor(plx) & mapheightperiod)|0;
            var heightonscreen = (camera.height - map.altitude[mapoffset]) * invz + camera.horizon|0;
            DrawVerticalLine(i, heightonscreen|0, hiddeny[i], map.color[mapoffset]);
            if (heightonscreen < hiddeny[i]) hiddeny[i] = heightonscreen;
            plx += dx;
            ply += dy;
        }
        deltaz += 0.005;
    }

    // Draw bullets
    bullets.forEach(bullet => {
        var dx = bullet.x - camera.x;
        var dy = bullet.y - camera.y;
        var dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 1) return;

        var sinSpawn = Math.sin(bullet.spawnAngle);
        var cosSpawn = Math.cos(bullet.spawnAngle);
        var invz = 1 / dist * 240;
        // Project relative to current camera for consistent perspective
        var relativeX = dx * cosang + dy * sinang;
        var screenX = relativeX * invz + screenwidth / 2;
        var screenY = ((bullet.z - camera.height) * invz + camera.horizon)|0;
        var radius = Math.max(2, 10 * (camera.distance - dist) / camera.distance)|0;
        if (screenX >= 0 && screenX < screenwidth) {
            DrawCircle(screenX|0, screenY|0, radius, 0xFFFFFF00);
        }
    });
}

function Draw() {
    updaterunning = true;
    UpdateCamera();
    DrawBackground();
    Render();
    Flip();
    frames++;
    window.requestAnimationFrame(Draw, 0);
}

function DownloadImagesAsync(urls) {
    return new Promise(function(resolve, reject) {
        var pending = urls.length;
        var result = [];
        if (pending === 0) {
            resolve([]);
            return;
        }
        urls.forEach(function(url, i) {
            var image = new Image();
            image.onload = function() {
                var tempcanvas = document.createElement("canvas");
                var tempcontext = tempcanvas.getContext("2d");
                tempcanvas.width = map.width;
                tempcanvas.height = map.height;
                tempcontext.drawImage(image, 0, 0, map.width, map.height);
                result[i] = tempcontext.getImageData(0, 0, map.width, map.height).data;
                pending--;
                if (pending === 0) {
                    resolve(result);
                }
            };
            image.src = url;
        });
    });
}

function LoadMap(filenames) {
    var files = filenames.split(";");
    DownloadImagesAsync(["maps/"+files[0]+".png", "maps/"+files[1]+".png"]).then(OnLoadedImages);
}

function OnLoadedImages(result) {
    var datac = result[0];
    var datah = result[1];
    for(var i=0; i<map.width*map.height; i++) {
        map.color[i] = 0xFF000000 | (datac[(i<<2) + 2] << 16) | (datac[(i<<2) + 1] << 8) | datac[(i<<2) + 0];
        map.altitude[i] = datah[i<<2];
    }
    Draw();
}

function OnResizeWindow() {
    screendata.canvas = document.getElementById('fullscreenCanvas');
    var aspect = window.innerWidth / window.innerHeight;
    screendata.canvas.width = window.innerWidth<800?window.innerWidth:800;
    screendata.canvas.height = screendata.canvas.width / aspect;
    if (screendata.canvas.getContext) {
        screendata.context = screendata.canvas.getContext('2d');
        screendata.imagedata = screendata.context.createImageData(screendata.canvas.width, screendata.canvas.height);
    }
    screendata.bufarray = new ArrayBuffer(screendata.imagedata.width * screendata.imagedata.height * 4);
    screendata.buf8 = new Uint8Array(screendata.bufarray);
    screendata.buf32 = new Uint32Array(screendata.bufarray);
    Draw();
}

function Init() {
    for(var i=0; i<map.width*map.height; i++) {
        map.color[i] = 0xFF007050;
        map.altitude[i] = 0;
    }
    LoadMap("C1W;D1");
    OnResizeWindow();

    var canvas = document.getElementById("fullscreenCanvas");
    window.onkeydown = DetectKeysDown;
    window.onkeyup = DetectKeysUp;
    canvas.onmousedown = DetectMouseDown;
    canvas.onmouseup = DetectMouseUp;
    window.onresize = OnResizeWindow;

    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
    canvas.onclick = function() {
        canvas.requestPointerLock();
    };
    document.addEventListener('pointerlockchange', function() {
        if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
            canvas.onmousemove = DetectMouseMove;
        } else {
            canvas.onmousemove = null;
        }
    }, false);

    window.setInterval(function(){
        var current = new Date().getTime();
        document.getElementById('fps').innerText = (frames / (current-timelastframe) * 1000).toFixed(1) + " fps";
        frames = 0;
        timelastframe = current;
    }, 2000);

    Draw();
}

Init();
</script>
</body>
</html>