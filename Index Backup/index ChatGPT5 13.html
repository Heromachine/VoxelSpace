<!DOCTYPE html>
<html>
<head>
    <title>Voxel Space Game</title>
    <meta charset="UTF-8">
    <style>
        html, body {margin: 0; height: 100%; overflow: hidden}
        canvas { width: 100%; height: 100%; display: block; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
        }

        #healthbar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid white;
            overflow: visible;
        }

        .hud-item {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 28px;
            height: 28px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
            pointer-events: none;
        }

        #health {width: 100%;height: 100%;background: #ff0000;}
        #info, #fps, #bulletcount, #lastbulletpos, #playerrotation, 
        #playerposition, #lastbulletdestroyedpos, #lastbulletdestroyedreason {
            position: absolute;
            padding: 5px;
            z-index: 100;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
        #info {top: 0;left: 10px;}
        #fps {top: 0;right: 10px;}
        #bulletcount {bottom: 10px;right: 10px;}
        #playerposition {bottom: 35px;right: 10px;}
        #playerrotation {bottom: 60px;right: 10px;}
        #lastbulletpos {bottom: 85px;right: 10px;}
        #lastbulletdestroyedpos {bottom: 110px;right: 10px;}
        #lastbulletdestroyedreason {bottom: 135px;right: 10px;}
    </style>
</head>
<body>

    <div id="controls" style="position: absolute; top: 50px; left: 10px; background: rgba(0, 0, 0, 0.7); color: white; padding: 10px;">
  <label for="fov">Camera FOV: <span id="fov-value">50</span></label><br>
  <input type="range" id="fov" min="10" max="120" value="50"><br>
  
  <label for="pitchOffset">Pitch Offset: <span id="pitchOffset-value">250</span></label><br>
  <input type="range" id="pitchOffset" min="0" max="500" value="250"><br>
  
  <label for="targetFPS">Target FPS: <span id="targetFPS-value">60</span></label><br>
  <input type="range" id="targetFPS" min="30" max="120" value="60"><br>
  
  <label for="frames">Frames: <span id="frames-value">0</span></label><br>
  <input type="range" id="frames" min="0" max="1000" value="0"><br>
</div>
    
<div id="crosshair"></div>
<div id="healthbar">
    <div id="health"></div>
    <div class="hud-item" style="background-image: url('images/heart.png');"></div>
</div>
<div id="fps"></div>
<div id="lastbulletdestroyedreason"></div>
<div id="lastbulletdestroyedpos"></div>
<div id="lastbulletpos"></div>
<div id="playerrotation"></div>
<div id="playerposition"></div>
<div id="bulletcount"></div>
<div id="info">Controls: WASD to move, Mouse to look, Left Click to shoot, Space to jump, Shift to sprint, C to crouch, R to reload</div>

<canvas id="fullscreenCanvas" width="800" height="400"></canvas>

<script>
"use strict";
var camera = {
    x: 0, y: 0, height: 78, angle: 0, horizon: 100,
    distance: 2000, velocityY: 0,
    focalLength: 300 // ðŸ”¹ shared focal length
};

var player={health:100,isCrouching:false,moveSpeed:1.5,sprintMultiplier:2,jumpStrength:5,crouchHeight:40,normalHeight:78},
    gun={magazine:200,maxMagazine:200,reloadTime:1000,isReloading:false,lastShot:0,fireRate:300},
    items=[], // unified bullets + hearts + pickups
    lastBullet=null,lastBulletDestroyedPos=null,lastBulletDestroyedReason=null,
    map={width:1024,height:1024,shift:10,altitude:new Uint8Array(1024*1024),color:new Uint32Array(1024*1024)},
    screendata={canvas:null,context:null,imagedata:null,bufarray:null,buf8:null,buf32:null,backgroundcolor:0xFFE09090,depthBuffer:null},
    input={forward:false,backward:false,left:false,right:false,jump:false,sprint:false,crouch:false,shoot:false,reload:false,mouseX:0,mouseY:0},
    updaterunning=false,time=Date.now(),timelastframe=Date.now(),frames=0,pitchOffset=250,targetFPS=60,frameDuration=1000/targetFPS,lastFrameTime=0,hiddeny;

// ===============================
// Item textures
var textures = {
    bullet: (() => { let i = new Image(); i.src = "images/bullet.png"; return i; })(),
    heart:  (() => { let i = new Image(); i.src = "images/heart.png";  return i; })(),
    tree:   (() => { let i = new Image(); i.src = "images/tree.png";   return i; })() // NEW
};



function spawnRandomItems(type, texture, options = {}) {
    let step = options.step || 8;               // spacing (avoid too many)
    let chance = options.chance || 0.01;        // probability per tile
    let colorCheck = options.colorCheck || (()=>true); // which terrain allowed

    for (let y = 0; y < map.height; y += step) {
        for (let x = 0; x < map.width; x += step) {
            let idx = (y << map.shift) + x;
            let col = map.color[idx] & 0xFFFFFF;  // strip alpha

            if (colorCheck(col)) {
                if (Math.random() < chance) {
                    let wx = x;
                    let wy = y;
                    let wz = getGroundHeight(wx, wy);
                    items.push({
                        type: type,
                        x: wx, y: wy, z: wz,
                        dx: 0, dy: 0, dz: 0,
                        image: texture
                    });
                }
            }
        }
    }
}


// ===============================
var getGroundHeight=(x,y)=>map.altitude[((Math.floor(y)&(map.width-1))<<map.shift)+(Math.floor(x)&(map.height-1))]+10;
var MAX_SLOPE=2;
var isOnGround=()=>camera.height<=getGroundHeight(camera.x,camera.y)+0.1;
var canMoveTo=(nx,ny)=>{if(!isOnGround())return true;var curH=getGroundHeight(camera.x,camera.y),newH=getGroundHeight(nx,ny);if(newH<=curH)return true;var horizDist=Math.hypot(nx-camera.x,ny-camera.y);if(!horizDist)return true;return (newH-curH)/horizDist<=MAX_SLOPE};

function horizonToPitchRad(h){return h*90/500*Math.PI/180;}

// ===============================
// Camera + item updates
function UpdateCamera(){
    var current=Date.now(),deltaTime=(current-time)*0.03,
        baseSpeed=player.moveSpeed*(input.sprint?player.sprintMultiplier:1)*deltaTime,nx,ny,slopeMult;

    // Movement
    if(input.forward){nx=camera.x-Math.sin(camera.angle)*baseSpeed;ny=camera.y-Math.cos(camera.angle)*baseSpeed;slopeMult=canMoveTo(nx,ny);camera.x+=(nx-camera.x)*slopeMult;camera.y+=(ny-camera.y)*slopeMult;}
    if(input.backward){nx=camera.x+Math.sin(camera.angle)*baseSpeed;ny=camera.y+Math.cos(camera.angle)*baseSpeed;slopeMult=canMoveTo(nx,ny);camera.x+=(nx-camera.x)*slopeMult;camera.y+=(ny-camera.y)*slopeMult;}
    if(input.left){nx=camera.x-Math.cos(camera.angle)*baseSpeed;ny=camera.y+Math.sin(camera.angle)*baseSpeed;slopeMult=canMoveTo(nx,ny);camera.x+=(nx-camera.x)*slopeMult;camera.y+=(ny-camera.y)*slopeMult;}
    if(input.right){nx=camera.x+Math.cos(camera.angle)*baseSpeed;ny=camera.y-Math.sin(camera.angle)*baseSpeed;slopeMult=canMoveTo(nx,ny);camera.x+=(nx-camera.x)*slopeMult;camera.y+=(ny-camera.y)*slopeMult;}

    camera.velocityY-=0.5*deltaTime;camera.height+=camera.velocityY*deltaTime;
    if(input.jump&&isOnGround())camera.velocityY=player.jumpStrength;

    if(input.crouch){if(!player.isCrouching){player.isCrouching=true;camera.height=player.crouchHeight;}}
    else if(player.isCrouching){player.isCrouching=false;camera.height=player.normalHeight;}

    var groundHeight=getGroundHeight(camera.x,camera.y);
    if(camera.height<groundHeight){camera.height=groundHeight;camera.velocityY=0;if(input.jump)camera.velocityY=player.jumpStrength;}

    // Shooting
    if(input.shoot&&!gun.isReloading&&gun.magazine>0&&current-gun.lastShot>gun.fireRate){
        var bulletSpeed=10,fx=-Math.sin(camera.angle),fy=-Math.cos(camera.angle),rx=Math.cos(camera.angle),ry=-Math.sin(camera.angle),
            pitch=horizonToPitchRad(camera.horizon-pitchOffset),horizScale=Math.cos(pitch),
            dirx=fx*horizScale,diry=fy*horizScale,dirz=Math.sin(pitch),mag=Math.hypot(dirx,diry,dirz)||1;
        dirx=(dirx/mag)*bulletSpeed;diry=(diry/mag)*bulletSpeed;dirz=(dirz/mag)*bulletSpeed;
        var muzzleOffset=1.0,spawnX=camera.x+fx*muzzleOffset,spawnY=camera.y+fy*muzzleOffset,spawnZ=camera.height;
        lastBulletDestroyedPos=null;lastBulletDestroyedReason=null;
        lastBullet={x:spawnX,y:spawnY,z:spawnZ};
        items.push({type:"bullet",x:spawnX,y:spawnY,z:spawnZ,dx:dirx,dy:diry,dz:dirz,distance:0,image:textures.bullet});
        gun.magazine--;gun.lastShot=current;
    }

    if(input.reload&&!gun.isReloading&&gun.magazine<gun.maxMagazine){
        gun.isReloading=true;setTimeout(()=>{gun.magazine=gun.maxMagazine;gun.isReloading=false;},gun.reloadTime);
    }

    // Update moving items (bullets only)
    items = items.filter(it=>{
        if(it.type==="bullet"){
            it.x+=it.dx*deltaTime;it.y+=it.dy*deltaTime;it.z+=it.dz*deltaTime;it.distance+=Math.hypot(it.dx,it.dy,it.dz)*deltaTime;
            var terrainHeight=getGroundHeight(it.x,it.y);
            if(it.z<=terrainHeight){if(it===lastBullet){lastBullet=null;lastBulletDestroyedPos={x:it.x,y:it.y,z:it.z};lastBulletDestroyedReason="Terrain Collision";}return false;}
            if(it.distance>=camera.distance){if(it===lastBullet){lastBullet=null;lastBulletDestroyedPos={x:it.x,y:it.y,z:it.z};lastBulletDestroyedReason="Too Far";}return false;}
        }
        return true;
    });

    // HUD updates
    document.getElementById('health').style.width=player.health+'%';
    document.getElementById('bulletcount').innerText=`Ammo: ${gun.magazine}/${gun.maxMagazine}`;
    document.getElementById('playerposition').innerText=`Pos: (${camera.x.toFixed(1)}, ${camera.y.toFixed(1)}, ${camera.height.toFixed(1)})`;
    document.getElementById('playerrotation').innerText=`Rot: ${(camera.angle*180/Math.PI).toFixed(1)}Â°, ${(camera.horizon*90/500).toFixed(1)}Â°`;
    document.getElementById('lastbulletpos').innerText=lastBullet?`Bullet: (${lastBullet.x.toFixed(1)}, ${lastBullet.y.toFixed(1)}, ${lastBullet.z.toFixed(1)})`:`Bullet: None`;
    document.getElementById('lastbulletdestroyedpos').innerText=lastBulletDestroyedPos?`Destroyed Pos: (${lastBulletDestroyedPos.x.toFixed(1)}, ${lastBulletDestroyedPos.y.toFixed(1)}, ${lastBulletDestroyedPos.z.toFixed(1)})`:`Destroyed Pos: None`;
    document.getElementById('lastbulletdestroyedreason').innerText=lastBulletDestroyedReason?`Destroyed: ${lastBulletDestroyedReason}`:`Destroyed: None`;

    time=current;
}

// ===============================
function DrawBackground(){
    var buf32=screendata.buf32,len=buf32.length,bg=screendata.backgroundcolor;
    screendata.depthBuffer.fill(Infinity);
    for(var i=0;i<len;i++)buf32[i]=bg;
}
function Flip(){screendata.imagedata.data.set(screendata.buf8);screendata.context.putImageData(screendata.imagedata,0,0);}

// ===============================
// Render terrain + items
function Render(){
    var sw=screendata.canvas.width,sh=screendata.canvas.height,
        sinang=Math.sin(camera.angle),cosang=Math.cos(camera.angle),
        deltaz=1,depth=screendata.depthBuffer;

    hiddeny.fill(sh);
    for(var z=1;z<camera.distance;z+=deltaz){
        var plx=-cosang*z-sinang*z,ply=sinang*z-cosang*z,prx=cosang*z-sinang*z,pry=-sinang*z-cosang*z,dx=(prx-plx)/sw,dy=(pry-ply)/sw;
        plx+=camera.x;ply+=camera.y;var invz = camera.focalLength / z;
        for(var i=0;i<sw;i++){
            var mapoffset=((Math.floor(ply)&(map.width-1))<<map.shift)+(Math.floor(plx)&(map.height-1));
            var heightonscreen=(camera.height-map.altitude[mapoffset])*invz+camera.horizon;
            if(heightonscreen<hiddeny[i]){
                for(var k=heightonscreen|0;k<hiddeny[i];k++){
                    var idx=k*sw+i;
                    if(z<depth[idx]){screendata.buf32[idx]=map.color[mapoffset];depth[idx]=z;}
                }
                hiddeny[i]=heightonscreen;
            }
            plx+=dx;ply+=dy;
        }
        if(z>1000)deltaz+=0.02;else deltaz+=0.005;
    }

    // Project & draw items
    var pitch=horizonToPitchRad(camera.horizon-pitchOffset),
        sinYaw=Math.sin(camera.angle),cosYaw=Math.cos(camera.angle),
        sinPitch=Math.sin(pitch),cosPitch=Math.cos(pitch),
        fx=-sinYaw*cosPitch,fy=-cosYaw*cosPitch,fz=sinPitch,
        rx=Math.cos(camera.angle),ry=-Math.sin(camera.angle),focal=camera.focalLength;


    items.forEach(it=>{
        var dx=it.x-camera.x,dy=it.y-camera.y,dz=it.z-camera.height,
            forward=dx*fx+dy*fy+dz*fz;
        if(forward<=0.1||forward>camera.distance)return;
        var right=dx*rx+dy*ry,invz=focal/forward,
            screenX=right*invz+sw/2,screenY=(camera.height-it.z)*invz+camera.horizon;
        if(screenX<-50||screenX>sw+50||screenY<-50||screenY>sh+50)return;

        var scale=10*invz;
        if(it.image.complete){
            screendata.context.drawImage(it.image, screenX-scale/2, screenY-scale/2, scale, scale);
        }
    });
}


function RenderItems(){
    var sw = screendata.canvas.width,
        sh = screendata.canvas.height,
        depth = screendata.depthBuffer,
        pitch = horizonToPitchRad(camera.horizon - pitchOffset),
        sinYaw = Math.sin(camera.angle), cosYaw = Math.cos(camera.angle),
        sinPitch = Math.sin(pitch), cosPitch = Math.cos(pitch),
        fx = -sinYaw * cosPitch, fy = -cosYaw * cosPitch, fz = sinPitch,
        rx = Math.cos(camera.angle), ry = -Math.sin(camera.angle),
            focal = camera.focalLength; 

    // ðŸ”¹ Step 1: project items + compute distance
    let projected = items.map(it=>{
        var dx = it.x - camera.x,
            dy = it.y - camera.y,
            dz = it.z - camera.height;

        var forward = dx*fx + dy*fy + dz*fz;
        return {it, dx, dy, dz, forward};
    });

    // ðŸ”¹ Step 2: filter valid + sort back-to-front
    projected = projected
        .filter(obj => obj.forward > 0.1 && obj.forward < camera.distance)
        .sort((a,b) => b.forward - a.forward); // far â†’ near

    // ðŸ”¹ Step 3: draw sorted
    projected.forEach(obj=>{
        let it = obj.it;
        let dx = obj.dx, dy = obj.dy, dz = obj.dz, forward = obj.forward;

        var right = dx*rx + dy*ry;
        var invz = camera.focalLength / forward;

        var screenX = right * invz + sw/2;
        var screenY = (camera.height - it.z) * invz + camera.horizon;

        if (screenX < 0 || screenX >= sw || screenY < 0 || screenY >= sh) return;

        var bufIndex = ((screenY|0) * sw + (screenX|0));
        if (bufIndex < 0 || bufIndex >= depth.length) return;
        if (forward >= depth[bufIndex]) return;

        var scale = 12 * invz;
        if (it.type === "tree") scale *= 3;

        if (it.image && it.image.complete) {
            screendata.context.drawImage(it.image,
                screenX - scale/2, screenY - scale,
                scale, scale
            );
        }
    });
}



function Draw(timestamp){
    updaterunning=true;
    if(timestamp-lastFrameTime>=frameDuration){
        lastFrameTime=timestamp;
        UpdateCamera();
        DrawBackground();
        Render();      // terrain into buffer
        Flip();        // push buffer to screen
        RenderItems(); // <--- draw sprites here
        frames++;
    }
    requestAnimationFrame(Draw);
}

// ===============================
function DownloadImagesAsync(urls){
    return new Promise(function(resolve){
        var pending=urls.length,result=[];if(!pending){resolve([]);return;}
        urls.forEach(function(url,i){var img=new Image();img.onload=function(){var tcv=document.createElement("canvas"),tcx=tcv.getContext("2d");tcv.width=map.width;tcv.height=map.height;tcx.drawImage(img,0,0,map.width,map.height);result[i]=tcx.getImageData(0,0,map.width,map.height).data;pending--;if(!pending)resolve(result);};img.src=url;});
    });
}
function LoadMap(files){var f=files.split(";");DownloadImagesAsync(["maps/"+f[0]+".png","maps/"+f[1]+".png"]).then(OnLoadedImages);}



function OnLoadedImages(result){
    var datac = result[0], datah = result[1];
    for (var i = 0; i < map.width * map.height; i++) {
        map.color[i] = 0xFF000000 |
                       (datac[(i<<2)+2] << 16) |
                       (datac[(i<<2)+1] << 8) |
                        datac[(i<<2)+0];
        map.altitude[i] = datah[i<<2];
    }

    // Start draw loop
    Draw();

    // Add one fixed heart as a test
    items.push({
        type: "heart",
        x: 20, y: 110, z: getGroundHeight(20,110)+50,
        dx: 0, dy: 0, dz: 0,
        image: textures.heart
    });

    // ðŸŒ³ Spawn random trees on green-ish terrain
    spawnRandomItems("tree", textures.tree, {
        step: 8,         // check every 8 pixels
        chance: 0.01,    // 1% chance
        colorCheck: (col) => ((col & 0x00FF00) > 0x004000) // must be green-ish
    });


}



function OnResizeWindow(){
    screendata.canvas=document.getElementById('fullscreenCanvas');
    var aspect=window.innerWidth/window.innerHeight;
    screendata.canvas.width=window.innerWidth<800?window.innerWidth:800;
    screendata.canvas.height=screendata.canvas.width/aspect;
    if(screendata.canvas.getContext){
        screendata.context=screendata.canvas.getContext('2d');
        screendata.imagedata=screendata.context.createImageData(screendata.canvas.width,screendata.canvas.height);
    }
    screendata.bufarray=new ArrayBuffer(screendata.imagedata.width*screendata.imagedata.height*4);
    screendata.buf8=new Uint8Array(screendata.bufarray);
    screendata.buf32=new Uint32Array(screendata.bufarray);
    screendata.depthBuffer=new Float32Array(screendata.canvas.width*screendata.canvas.height);
    hiddeny=new Int32Array(screendata.canvas.width);
}
function Init(){
    for(var i=0;i<map.width*map.height;i++){map.color[i]=0xFF007050;map.altitude[i]=0;}
    LoadMap("C1W;D1");OnResizeWindow();
    var canvas=document.getElementById("fullscreenCanvas");
    window.onkeydown=DetectKeysDown;window.onkeyup=DetectKeysUp;
    canvas.onmousedown=DetectMouseDown;canvas.onmouseup=DetectMouseUp;
    window.onresize=OnResizeWindow;
    canvas.requestPointerLock=canvas.requestPointerLock||canvas.mozRequestPointerLock;
    canvas.onclick=function(){canvas.requestPointerLock();};
    document.addEventListener('pointerlockchange',function(){
        if(document.pointerLockElement===canvas||document.mozPointerLockElement===canvas){canvas.onmousemove=DetectMouseMove;}
        else{canvas.onmousemove=null;}
    },false);
    setInterval(function(){var current=Date.now();document.getElementById('fps').innerText=(frames/(current-timelastframe)*1000).toFixed(1)+" fps";frames=0;timelastframe=current;},2000);
}
// ===============================
// Controls
function DetectKeysDown(e){switch(e.keyCode){case 87:input.forward=true;break;case 83:input.backward=true;break;case 65:input.left=true;break;case 68:input.right=true;break;case 32:input.jump=true;break;case 16:input.sprint=true;break;case 67:input.crouch=true;break;case 82:input.reload=true;break;}if(!updaterunning){time=Date.now();Draw();}}
function DetectKeysUp(e){switch(e.keyCode){case 87:input.forward=false;break;case 83:input.backward=false;break;case 65:input.left=false;break;case 68:input.right=false;break;case 32:input.jump=false;break;case 16:input.sprint=false;break;case 67:input.crouch=false;break;case 82:input.reload=false;break;}}
function DetectMouseDown(e){if(e.button===0)input.shoot=true;}
function DetectMouseUp(e){if(e.button===0)input.shoot=false;}
function DetectMouseMove(e){camera.angle=(camera.angle-e.movementX*0.002)%(2*Math.PI);if(camera.angle<0)camera.angle+=2*Math.PI;camera.horizon=Math.max(-400,Math.min(600,camera.horizon-e.movementY*0.2));}

// ===============================
Init();
</script>
</body>
</html>
