<!DOCTYPE html>
<html>
<head>
    <title>Voxel Space Game</title>
    <meta charset="UTF-8">
    <style>
        html, body {margin: 0; height: 100%; overflow: hidden}
        canvas { width: 100%; height: 100%; display: block; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
        }
        #healthbar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid white;
        }
        #health {
            width: 100%;
            height: 100%;
            background: #ff0000;
        }
        #info {
            position: absolute;
            top: 0px;
            left: 10px;
            padding: 5px;
            z-index: 100;
            color: white;
            font-family: "Arial", sans-serif;
            font-size: 16px;
        }
        #fps {
            position: absolute;
            top: 0px;
            right: 10px;
            padding: 5px;
            z-index: 100;
            color: white;
            font-family: "Arial", sans-serif;
            font-size: 16px;
        }
        #bulletcount, #lastbulletpos, #playerrotation, #playerposition, #lastbulletdestroyedpos, #lastbulletdestroyedreason {
            position: absolute;
            right: 10px;
            padding: 5px;
            z-index: 100;
            color: white;
            font-family: "Arial", sans-serif;
            font-size: 16px;
        }
        #bulletcount { bottom: 10px; }
        #playerposition { bottom: 35px; }
        #playerrotation { bottom: 60px; }
        #lastbulletpos { bottom: 85px; }
        #lastbulletdestroyedpos { bottom: 110px; }
        #lastbulletdestroyedreason { bottom: 135px; }
    </style>
</head>

<body>
<div id="crosshair"></div>
<div id="healthbar">
    <div id="health"></div>
</div>
<div id="fps"></div>
<div id="lastbulletdestroyedreason"></div>
<div id="lastbulletdestroyedpos"></div>
<div id="lastbulletpos"></div>
<div id="playerrotation"></div>
<div id="playerposition"></div>
<div id="bulletcount"></div>
<div id="info">
    Controls: WASD to move, Mouse to look, Left Click to shoot, Space to jump, Shift to sprint, C to crouch, R to reload
</div>

<canvas id="fullscreenCanvas" width="800" height="400">
    Your browser does not support the canvas element.
</canvas>

<script>
"use strict";

var camera = {
    x: 0,
    y: 0,
    height: 78,
    angle: 0,
    horizon: 100, // custom horizon units used by your engine
    distance: 800,
    velocityY: 0
};

var player = {
    health: 100,
    isCrouching: false,
    moveSpeed: 1.5,
    sprintMultiplier: 2,
    jumpStrength: 15,
    crouchHeight: 40,
    normalHeight: 78
};

var gun = {
    magazine: 200,
    maxMagazine: 200,
    reloadTime: 1000,
    isReloading: false,
    lastShot: 0,
    fireRate: 300
};

var bullets = [];
var lastBullet = null;
var lastBulletDestroyedPos = null;
var lastBulletDestroyedReason = null;

var map = {
    width: 1024,
    height: 1024,
    shift: 10,
    altitude: new Uint8Array(1024*1024),
    color: new Uint32Array(1024*1024)
};

var screendata = {
    canvas: null,
    context: null,
    imagedata: null,
    bufarray: null,
    buf8: null,
    buf32: null,
    backgroundcolor: 0xFFE09090
};

var input = {
    forward: false,
    backward: false,
    left: false,
    right: false,
    jump: false,
    sprint: false,
    crouch: false,
    shoot: false,
    reload: false,
    mouseX: 0,
    mouseY: 0
};

var updaterunning = false;
var time = new Date().getTime();
var timelastframe = new Date().getTime();
var frames = 0;

function getGroundHeight(x, y) {
    var offset = ((Math.floor(y) & (map.width - 1)) << map.shift) +
                 (Math.floor(x) & (map.height - 1)) | 0;
    return map.altitude[offset] + 10; // consistent with ground collision elsewhere
}

var MAX_SLOPE = 1; // tan(45°)

function isOnGround() {
    var mapoffset = ((Math.floor(camera.y) & (map.width-1)) << map.shift) + (Math.floor(camera.x) & (map.height-1))|0;
    return camera.height <= map.altitude[mapoffset] + 10 + 0.1;
}

function canMoveTo(nx, ny) {
    // allow air movement (so jumps can clear steep terrain)
    if (!isOnGround()) return true;

    var curHeight = getGroundHeight(camera.x, camera.y);
    var newHeight = getGroundHeight(nx, ny);

    // If moving downhill or flat, always allow
    if (newHeight <= curHeight) return true;

    var horizDist = Math.sqrt((nx - camera.x) * (nx - camera.x) + (ny - camera.y) * (ny - camera.y));
    if (horizDist === 0) return true;

    var slope = (newHeight - curHeight) / horizDist;
    return slope <= MAX_SLOPE;
}

// Convert camera.horizon units to pitch radians consistently with the rotation display used elsewhere.
// Your display used ((camera.horizon) * 90 / 500)° — we will convert the same way:
function horizonToPitchRad(horizon) {
    var pitchDeg = horizon * 90 / 500; // degrees
    return pitchDeg * Math.PI / 180;  // radians
}

function UpdateCamera() {
    var current = new Date().getTime();
    // Keep your deltaTime scaling consistent with rest of code.
    var deltaTime = (current - time) * 0.03;

    // Movement
    let speed = player.moveSpeed * (input.sprint ? player.sprintMultiplier : 1) * deltaTime;

    if (input.forward) {
        var nx = camera.x - Math.sin(camera.angle) * speed;
        var ny = camera.y - Math.cos(camera.angle) * speed;
        if (canMoveTo(nx, ny)) {
            camera.x = nx;
            camera.y = ny;
        }
    }
    if (input.backward) {
        var nx = camera.x + Math.sin(camera.angle) * speed;
        var ny = camera.y + Math.cos(camera.angle) * speed;
        if (canMoveTo(nx, ny)) {
            camera.x = nx;
            camera.y = ny;
        }
    }
    if (input.left) {
        var nx = camera.x - Math.cos(camera.angle) * speed;
        var ny = camera.y + Math.sin(camera.angle) * speed;
        if (canMoveTo(nx, ny)) {
            camera.x = nx;
            camera.y = ny;
        }
    }
    if (input.right) {
        var nx = camera.x + Math.cos(camera.angle) * speed;
        var ny = camera.y - Math.sin(camera.angle) * speed;
        if (canMoveTo(nx, ny)) {
            camera.x = nx;
            camera.y = ny;
        }
    }

    // Apply gravity
    camera.velocityY -= 0.5 * deltaTime;
    camera.height += camera.velocityY * deltaTime;

    // Jumping
    if (input.jump && isOnGround()) {
        camera.velocityY = player.jumpStrength;
    }

    // Crouching
    if (input.crouch) {
        if (!player.isCrouching) {
            player.isCrouching = true;
            camera.height = player.crouchHeight;
        }
    } else if (player.isCrouching) {
        player.isCrouching = false;
        camera.height = player.normalHeight;
    }

    // Ground collision
    var mapoffset = ((Math.floor(camera.y) & (map.width-1)) << map.shift) + (Math.floor(camera.x) & (map.height-1))|0;
    var groundHeight = map.altitude[mapoffset] + 10;
    if (camera.height < groundHeight) {
        camera.height = groundHeight;
        camera.velocityY = 0;
        if (input.jump) {
            camera.velocityY = player.jumpStrength;
        }
    }

    // Shooting - cleaned and consistent
    if (input.shoot && !gun.isReloading && gun.magazine > 0 && current - gun.lastShot > gun.fireRate) {
        var bulletSpeed = 10; // units per second (kept from before)
        // Camera forward/right in world-space (same basis used by rendering)
        var fx = -Math.sin(camera.angle);
        var fy = -Math.cos(camera.angle);
        var rx = Math.cos(camera.angle);
        var ry = -Math.sin(camera.angle);

        // Pitch from horizon (consistent conversion)
        var pitch = horizonToPitchRad(camera.horizon); // radians
        var horizScale = Math.cos(pitch);
        var dirx = fx * horizScale;
        var diry = fy * horizScale;
        var dirz = Math.sin(pitch);

        // Normalize direction then scale by bulletSpeed
        var mag = Math.sqrt(dirx*dirx + diry*diry + dirz*dirz) || 1;
        dirx = (dirx / mag) * bulletSpeed;
        diry = (diry / mag) * bulletSpeed;
        dirz = (dirz / mag) * bulletSpeed;

        // Spawn bullet slightly forward of the camera so it appears from muzzle/crosshair
        var muzzleOffset = 1.0; // small forward offset in world units
        var spawnX = camera.x + fx * muzzleOffset + rx * 0; // no right offset for now
        var spawnY = camera.y + fy * muzzleOffset + ry * 0;
        var spawnZ = camera.height + 0; // spawn at eye height

        lastBulletDestroyedPos = null;
        lastBulletDestroyedReason = null;
        lastBullet = {
            x: spawnX,
            y: spawnY,
            z: spawnZ,
            dx: dirx,
            dy: diry,
            dz: dirz,
            distance: 0,
            spawnAngle: camera.angle
        };
        bullets.push(lastBullet);
        gun.magazine--;
        gun.lastShot = current;
    }

    // Reloading
    if (input.reload && !gun.isReloading && gun.magazine < gun.maxMagazine) {
        gun.isReloading = true;
        setTimeout(() => {
            gun.magazine = gun.maxMagazine;
            gun.isReloading = false;
        }, gun.reloadTime);
    }

    // Update bullets (world movement)
    // deltaDistance uses same deltaTime scale as position updates
    bullets = bullets.filter(bullet => {
        bullet.x += bullet.dx * deltaTime;
        bullet.y += bullet.dy * deltaTime;
        bullet.z += bullet.dz * deltaTime;
        bullet.distance += Math.sqrt(bullet.dx * bullet.dx + bullet.dy * bullet.dy + bullet.dz * bullet.dz) * deltaTime;

        // Terrain collision: match ground offset +10 used elsewhere
        var bulletMapOffset = ((Math.floor(bullet.y) & (map.width-1)) << map.shift) + (Math.floor(bullet.x) & (map.height-1))|0;
        var terrainHeight = map.altitude[bulletMapOffset] + 10;
        if (bullet.z <= terrainHeight) {
            if (bullet === lastBullet) {
                lastBullet = null;
                lastBulletDestroyedPos = { x: bullet.x, y: bullet.y, z: bullet.z };
                lastBulletDestroyedReason = "Terrain Collision";
            }
            return false;
        }
        // Distance culling (same camera.distance)
        if (bullet.distance >= camera.distance) {
            if (bullet === lastBullet) {
                lastBullet = null;
                lastBulletDestroyedPos = { x: bullet.x, y: bullet.y, z: bullet.z };
                lastBulletDestroyedReason = "Too Far";
            }
            return false;
        }
        return true;
    });

    // Update UI
    document.getElementById('health').style.width = player.health + '%';
    document.getElementById('bulletcount').innerText = `Ammo: ${gun.magazine}/${gun.maxMagazine}`;
    document.getElementById('playerposition').innerText = `Pos: (${camera.x.toFixed(1)}, ${camera.y.toFixed(1)}, ${camera.height.toFixed(1)})`;
    document.getElementById('playerrotation').innerText = `Rot: (${(camera.angle * 180 / Math.PI).toFixed(1)}°, ${((camera.horizon) * 90 / 500).toFixed(1)}°)`;
    document.getElementById('lastbulletpos').innerText = lastBullet ? 
        `Bullet: (${lastBullet.x.toFixed(1)}, ${lastBullet.y.toFixed(1)}, ${lastBullet.z.toFixed(1)})` : 
        `Bullet: None`;
    document.getElementById('lastbulletdestroyedpos').innerText = lastBulletDestroyedPos ? 
        `Destroyed Pos: (${lastBulletDestroyedPos.x.toFixed(1)}, ${lastBulletDestroyedPos.y.toFixed(1)}, ${lastBulletDestroyedPos.z.toFixed(1)})` : 
        `Destroyed Pos: None`;
    document.getElementById('lastbulletdestroyedreason').innerText = lastBulletDestroyedReason ? 
        `Destroyed: ${lastBulletDestroyedReason}` : 
        `Destroyed: None`;

    time = current;
}

function DetectKeysDown(e) {
    switch(e.keyCode) {
        case 87: // W
            input.forward = true;
            break;
        case 83: // S
            input.backward = true;
            break;
        case 65: // A
            input.left = true;
            break;
        case 68: // D
            input.right = true;
            break;
        case 32: // Space
            input.jump = true;
            break;
        case 16: // Shift
            input.sprint = true;
            break;
        case 67: // C
            input.crouch = true;
            break;
        case 82: // R
            input.reload = true;
            break;
    }
    if (!updaterunning) {
        time = new Date().getTime();
        Draw();
    }
}

function DetectKeysUp(e) {
    switch(e.keyCode) {
        case 87: // W
            input.forward = false;
            break;
        case 83: // S
            input.backward = false;
            break;
        case 65: // A
            input.left = false;
            break;
        case 68: // D
            input.right = false;
            break;
        case 32: // Space
            input.jump = false;
            break;
        case 16: // Shift
            input.sprint = false;
            break;
        case 67: // C
            input.crouch = false;
            break;
        case 82: // R
            input.reload = false;
            break;
    }
}

function DetectMouseDown(e) {
    if (e.button === 0) {
        input.shoot = true;
    }
}

function DetectMouseUp(e) {
    if (e.button === 0) {
        input.shoot = false;
    }
}

function DetectMouseMove(e) {
    camera.angle -= e.movementX * 0.002;
    // Normalize angle to [0, 2π)
    while (camera.angle >= 2 * Math.PI) camera.angle -= 2 * Math.PI;
    while (camera.angle < 0) camera.angle += 2 * Math.PI;
    camera.horizon -= e.movementY * 0.2;
    camera.horizon = Math.max(-400, Math.min(600, camera.horizon));
}

function DrawVerticalLine(x, ytop, ybottom, col) {
    x = x|0;
    ytop = ytop|0;
    ybottom = ybottom|0;
    col = col|0;
    var buf32 = screendata.buf32;
    var screenwidth = screendata.canvas.width|0;
    if (ytop < 0) ytop = 0;
    if (ytop > ybottom) return;

    var offset = ((ytop * screenwidth) + x)|0;
    for (var k = ytop|0; k < ybottom|0; k=k+1|0) {
        buf32[offset|0] = col|0;
        offset = offset + screenwidth|0;
    }
}

function DrawCircle(x, y, radius, col) {
    x = x|0;
    y = y|0;
    radius = radius|0;
    col = col|0;
    var buf32 = screendata.buf32;
    var screenwidth = screendata.canvas.width|0;
    var screenheight = screendata.canvas.height|0;

    for (var i = -radius; i <= radius; i++) {
        for (var j = -radius; j <= radius; j++) {
            if (i*i + j*j <= radius*radius) {
                var px = x + i;
                var py = y + j;
                if (px >= 0 && px < screenwidth && py >= 0 && py < screenheight) {
                    buf32[(py * screenwidth + px)|0] = col|0;
                }
            }
        }
    }
}

function DrawBackground() {
    var buf32 = screendata.buf32;
    var color = screendata.backgroundcolor|0;
    for (var i = 0; i < buf32.length; i++) buf32[i] = color|0;
}

function Flip() {
    screendata.imagedata.data.set(screendata.buf8);
    screendata.context.putImageData(screendata.imagedata, 0, 0);
}

function Render() {
    var mapwidthperiod = map.width - 1;
    var mapheightperiod = map.height - 1;
    var screenwidth = screendata.canvas.width | 0;
    var screenheight = screendata.canvas.height | 0;
    var sinang = Math.sin(camera.angle);
    var cosang = Math.cos(camera.angle);
    var hiddeny = new Int32Array(screenwidth);
    for (var i = 0; i < screenwidth | 0; i = i + 1 | 0)
        hiddeny[i] = screendata.canvas.height;
    var deltaz = 1.;

    // --- Terrain rendering (unchanged) ---
    for (var z = 1; z < camera.distance; z += deltaz) {
        var plx = -cosang * z - sinang * z;
        var ply = sinang * z - cosang * z;
        var prx = cosang * z - sinang * z;
        var pry = -sinang * z - cosang * z;
        var dx = (prx - plx) / screenwidth;
        var dy = (pry - ply) / screenwidth;
        plx += camera.x;
        ply += camera.y;
        var invz = 1. / z * 240.;
        for (var i = 0; i < screenwidth | 0; i = i + 1 | 0) {
            var mapoffset = ((Math.floor(ply) & mapwidthperiod) << map.shift) + (Math.floor(plx) & mapheightperiod) | 0;
            var heightonscreen = (camera.height - map.altitude[mapoffset]) * invz + camera.horizon | 0;
            DrawVerticalLine(i, heightonscreen | 0, hiddeny[i], map.color[mapoffset]);
            if (heightonscreen < hiddeny[i]) hiddeny[i] = heightonscreen;
            plx += dx;
            ply += dy;
        }
        deltaz += 0.005;
    }

    // --- Bullet rendering (new, correct camera-space projection) ---
    // Build an orthonormal camera basis from yaw + pitch:
    var pitch = horizonToPitchRad(camera.horizon); // convert your horizon->pitch the same way you do for firing
    var sinYaw = Math.sin(camera.angle);
    var cosYaw = Math.cos(camera.angle);
    var sinPitch = Math.sin(pitch);
    var cosPitch = Math.cos(pitch);

    // Forward vector (unit) in world space (accounts for pitch)
    var fx = -sinYaw * cosPitch;
    var fy = -cosYaw * cosPitch;
    var fz = sinPitch;

    // Right vector (unit) in world space (derived from world-up cross forward)
    var rx = cosYaw;
    var ry = -sinYaw;
    var rz = 0;

    // Up vector = cross(forward, right) (orthonormal)
    var ux = fy * rz - fz * ry; // -fz * ry
    var uy = fz * rx - fx * rz; //  fz * rx
    var uz = fx * ry - fy * rx;

    // Use same "depth scale" as terrain so things line up visually
    var focal = 240;

    bullets.forEach(bullet => {
        // world-space vector from camera to bullet
        var vx = bullet.x - camera.x;
        var vy = bullet.y - camera.y;
        var vz = bullet.z - camera.height;

        // camera-space coordinates = dot(worldVector, basis)
        var camZ = vx * fx + vy * fy + vz * fz; // forward distance
        if (camZ <= 0.1) return;                // behind camera
        if (camZ > camera.distance) return;     // too far

        var camX = vx * rx + vy * ry + vz * rz; // right distance
        var camY = vx * ux + vy * uy + vz * uz; // up distance

        var invz = focal / camZ;
        var screenX = (camX * invz) + (screenwidth / 2);
        // match the same horizon offset convention used by terrain (keeps vertical alignment)
        var screenY = (screenheight / 2) - (camY * invz) + (camera.horizon * 0.5);

        // quick off-screen test
        if (screenX < -50 || screenX > screenwidth + 50 || screenY < -50 || screenY > screenheight + 50) {
            return;
        }

        // size by distance
        var t = Math.max(0, 1 - (camZ / camera.distance));
        var radius = Math.max(1, Math.floor(2 + t * 8));

        DrawCircle(Math.floor(screenX), Math.floor(screenY), radius, 0xFFFFFF00);
    });
}


function Draw() {
    updaterunning = true;
    UpdateCamera();
    DrawBackground();
    Render();
    Flip();
    frames++;
    window.requestAnimationFrame(Draw, 0);
}

function DownloadImagesAsync(urls) {
    return new Promise(function(resolve, reject) {
        var pending = urls.length;
        var result = [];
        if (pending === 0) {
            resolve([]);
            return;
        }
        urls.forEach(function(url, i) {
            var image = new Image();
            image.onload = function() {
                var tempcanvas = document.createElement("canvas");
                var tempcontext = tempcanvas.getContext("2d");
                tempcanvas.width = map.width;
                tempcanvas.height = map.height;
                tempcontext.drawImage(image, 0, 0, map.width, map.height);
                result[i] = tempcontext.getImageData(0, 0, map.width, map.height).data;
                pending--;
                if (pending === 0) {
                    resolve(result);
                }
            };
            image.src = url;
        });
    });
}

function LoadMap(filenames) {
    var files = filenames.split(";");
    DownloadImagesAsync(["maps/"+files[0]+".png", "maps/"+files[1]+".png"]).then(OnLoadedImages);
}

function OnLoadedImages(result) {
    var datac = result[0];
    var datah = result[1];
    for(var i=0; i<map.width*map.height; i++) {
        map.color[i] = 0xFF000000 | (datac[(i<<2) + 2] << 16) | (datac[(i<<2) + 1] << 8) | datac[(i<<2) + 0];
        map.altitude[i] = datah[i<<2];
    }
    Draw();
}

function OnResizeWindow() {
    screendata.canvas = document.getElementById('fullscreenCanvas');
    var aspect = window.innerWidth / window.innerHeight;
    screendata.canvas.width = window.innerWidth<800?window.innerWidth:800;
    screendata.canvas.height = screendata.canvas.width / aspect;
    if (screendata.canvas.getContext) {
        screendata.context = screendata.canvas.getContext('2d');
        screendata.imagedata = screendata.context.createImageData(screendata.canvas.width, screendata.canvas.height);
    }
    screendata.bufarray = new ArrayBuffer(screendata.imagedata.width * screendata.imagedata.height * 4);
    screendata.buf8 = new Uint8Array(screendata.bufarray);
    screendata.buf32 = new Uint32Array(screendata.bufarray);
    Draw();
}

function Init() {
    for(var i=0; i<map.width*map.height; i++) {
        map.color[i] = 0xFF007050;
        map.altitude[i] = 0;
    }
    LoadMap("C1W;D1");
    OnResizeWindow();

    var canvas = document.getElementById("fullscreenCanvas");
    window.onkeydown = DetectKeysDown;
    window.onkeyup = DetectKeysUp;
    canvas.onmousedown = DetectMouseDown;
    canvas.onmouseup = DetectMouseUp;
    window.onresize = OnResizeWindow;

    canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
    canvas.onclick = function() {
        canvas.requestPointerLock();
    };
    document.addEventListener('pointerlockchange', function() {
        if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
            canvas.onmousemove = DetectMouseMove;
        } else {
            canvas.onmousemove = null;
        }
    }, false);

    window.setInterval(function(){
        var current = new Date().getTime();
        document.getElementById('fps').innerText = (frames / (current-timelastframe) * 1000).toFixed(1) + " fps";
        frames = 0;
        timelastframe = current;
    }, 2000);

    Draw();
}

Init();
</script>
</body>
</html>
