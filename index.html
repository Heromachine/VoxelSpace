<!--
    VoxelSpace FPS Game

    Based on VoxelSpace by Sebastian Macke (s-macke)
    Original repository: https://github.com/s-macke/VoxelSpace

    The Voxel Space rendering engine and terrain maps are derived from
    the original project, which reverse-engineered the technique from
    NovaLogic's Comanche (1992).

    Original code licensed under MIT License.
    Terrain maps are reverse-engineered from Comanche and excluded from license.

    Modifications and game features by Heromachine
-->
<!DOCTYPE html>
<html>
<head>
    <title>Voxel Space Game</title>
    <meta charset="UTF-8">
    <style>
        html, body {margin: 0; height: 100%; overflow: hidden; background: #000;}

        /* Game container - holds canvas and HUD, gets centered */
        #game-container {
            position: absolute;
            overflow: hidden;
        }

        #game-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            z-index: 10;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
        }

        #healthbar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid white;
            overflow: visible;
            z-index: 10;
        }

        #jumpbar {
            position: absolute;
            bottom: 40px;
            left: 10px;
            width: 200px;
            height: 10px;
            background: #333;
            border: 2px solid white;
            display: none;
            z-index: 10;
        }

        #jumpcharge {
            width: 0%;
            height: 100%;
            background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
            transition: width 0.05s;
        }

        .hud-item {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 28px;
            height: 28px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
            pointer-events: none;
        }

        #health {width: 100%;height: 100%;background: #ff0000;}
        /* Debug info and controls hidden - moved to Debug tab */
        #info, #fps, #bulletcount, #lastbulletpos, #lastbulletscreen, #playerrotation,
        #playerposition, #lastbulletdestroyedpos, #lastbulletdestroyedreason {
            display: none;
        }
    </style>
</head>
<body>

    <div id="controls" style="display: none; position: absolute; top: 50px; left: 10px; background: rgba(0, 0, 0, 0.85); color: white; padding: 0; width: 360px; border-radius: 5px; overflow: hidden; z-index: 100;">
  <!-- Panel Title -->
  <div style="background: #222; padding: 8px 10px; font-weight: bold; font-size: 13px; border-bottom: 1px solid #444;">Settings <span style="float:right; font-weight:normal; font-size:10px; color:#888;">[ESC] toggle</span></div>
  <!-- Tab buttons -->
  <div style="display: flex; background: #333;">
    <button class="tab-btn active" data-tab="camera" style="flex:1;padding:8px 4px;border:none;background:#555;color:white;cursor:pointer;font-size:11px;">Camera</button>
    <button class="tab-btn" data-tab="player" style="flex:1;padding:8px 4px;border:none;background:#333;color:#aaa;cursor:pointer;font-size:11px;">Player</button>
    <button class="tab-btn" data-tab="bullet" style="flex:1;padding:8px 4px;border:none;background:#333;color:#aaa;cursor:pointer;font-size:11px;">Bullet</button>
    <button class="tab-btn" data-tab="hit" style="flex:1;padding:8px 4px;border:none;background:#333;color:#aaa;cursor:pointer;font-size:11px;">Hit</button>
    <button class="tab-btn" data-tab="gun" style="flex:1;padding:8px 4px;border:none;background:#333;color:#aaa;cursor:pointer;font-size:11px;">Gun</button>
    <button class="tab-btn" data-tab="barrel" style="flex:1;padding:8px 4px;border:none;background:#333;color:#aaa;cursor:pointer;font-size:11px;">Barrel</button>
    <button class="tab-btn" data-tab="ui" style="flex:1;padding:8px 4px;border:none;background:#333;color:#aaa;cursor:pointer;font-size:11px;">UI</button>
    <button class="tab-btn" data-tab="gmd" style="flex:1;padding:8px 4px;border:none;background:#333;color:#aaa;cursor:pointer;font-size:11px;">GMD</button>
    <button class="tab-btn" data-tab="debug" style="flex:1;padding:8px 4px;border:none;background:#333;color:#aaa;cursor:pointer;font-size:11px;">Debug</button>
  </div>

  <!-- Camera Tab -->
  <div class="tab-content" id="tab-camera" style="padding: 10px;">
    <label for="fov">Focal Length: <span id="fov-value">300</span></label><br>
    <input type="range" id="fov" min="100" max="800" value="300" style="width:100%;"><br>

    <label for="pitchOffset">Pitch Offset: <span id="pitchOffset-value">250</span></label><br>
    <input type="range" id="pitchOffset" min="0" max="500" value="250" style="width:100%;"><br>

    <label for="targetFPS">Target FPS: <span id="targetFPS-value">60</span></label><br>
    <input type="range" id="targetFPS" min="30" max="120" value="60" style="width:100%;"><br>

    <label for="frames">Frames: <span id="frames-value">0</span></label><br>
    <input type="range" id="frames" min="0" max="1000" value="0" style="width:100%;">
  </div>

  <!-- Player Tab -->
  <div class="tab-content" id="tab-player" style="padding: 10px; display: none;">
    <label for="playerHeight">Eye Height: <span id="playerHeight-value">30</span></label><br>
    <input type="range" id="playerHeight" min="5" max="150" value="30" style="width:100%;"><br>

    <label for="normalHeight">Standing: <span id="normalHeight-value">78</span></label><br>
    <input type="range" id="normalHeight" min="40" max="150" value="78" style="width:100%;"><br>

    <label for="crouchHeight">Crouch: <span id="crouchHeight-value">40</span></label><br>
    <input type="range" id="crouchHeight" min="20" max="100" value="40" style="width:100%;"><br>

    <label for="jumpMin">Jump Min: <span id="jumpMin-value">3</span></label><br>
    <input type="range" id="jumpMin" min="1" max="10" value="3" style="width:100%;"><br>

    <label for="jumpMax">Jump Max: <span id="jumpMax-value">12</span></label><br>
    <input type="range" id="jumpMax" min="5" max="30" value="12" style="width:100%;"><br>

    <hr style="border-color:#555;margin:8px 0;">
    <label for="walkSpeed">Walk Speed: <span id="walkSpeed-value">1.5</span></label><br>
    <input type="range" id="walkSpeed" min="0.5" max="5" step="0.1" value="1.5" style="width:100%;"><br>

    <label for="sprintMultiplier">Sprint Multiplier: <span id="sprintMultiplier-value">2.0</span>x</label><br>
    <input type="range" id="sprintMultiplier" min="1" max="5" step="0.1" value="2" style="width:100%;">
  </div>

  <!-- Bullet Tab -->
  <div class="tab-content" id="tab-bullet" style="padding: 10px; display: none;">
    <label for="bulletSize">Size: <span id="bulletSize-value">0.75</span></label><br>
    <input type="range" id="bulletSize" min="0.1" max="3" step="0.1" value="0.75" style="width:100%;"><br>

    <label for="barrelDistance">Barrel Dist: <span id="barrelDistance-value">5</span></label><br>
    <input type="range" id="barrelDistance" min="1" max="50" value="5" style="width:100%;">
  </div>

  <!-- Hit Detection Tab -->
  <div class="tab-content" id="tab-hit" style="padding: 10px; display: none;">
    <b style="font-size:10px; color:#ff6666;">Hitscan (Instant)</b><br>
    <label for="hitscanDist">Distance: <span id="hitscanDist-value">50</span></label><br>
    <input type="range" id="hitscanDist" min="0" max="200" value="50" style="width:100%;"><br>

    <b style="font-size:10px; color:#66aaff;">CCD (Projectile)</b><br>
    <label for="ccdMaxDist">Max Distance: <span id="ccdMaxDist-value">500</span></label><br>
    <input type="range" id="ccdMaxDist" min="100" max="1000" step="50" value="500" style="width:100%;"><br>

    <label style="font-size:11px;"><input type="checkbox" id="showHitRanges" checked> Show range circles on minimap</label>
  </div>

  <!-- Gun Tab -->
  <div class="tab-content" id="tab-gun" style="padding: 10px; display: none;">
    <div style="margin-bottom:8px;">
      <b style="font-size:10px;">Edit Position:</b>
      <button id="editADS" style="padding:2px 8px;margin-left:5px;background:#4CAF50;color:white;border:none;cursor:pointer;">ADS</button>
      <button id="editHip" style="padding:2px 8px;margin-left:5px;background:#555;color:white;border:none;cursor:pointer;">Hip</button>
      <span id="editModeLabel" style="margin-left:10px;font-size:10px;color:#4CAF50;">[Editing ADS]</span>
    </div>

    <label for="gunX">X Offset: <span id="gunX-value">0</span></label><br>
    <input type="range" id="gunX" min="-200" max="400" value="0" style="width:100%;"><br>

    <label for="gunY">Y Offset: <span id="gunY-value">100</span></label><br>
    <input type="range" id="gunY" min="-200" max="400" value="100" style="width:100%;"><br>

    <label for="gunZ">Z Depth: <span id="gunZ-value">0</span></label><br>
    <input type="range" id="gunZ" min="-100" max="100" value="0" style="width:100%;"><br>

    <label for="gunScale">Scale: <span id="gunScale-value">350</span></label><br>
    <input type="range" id="gunScale" min="50" max="1000" value="350" style="width:100%;"><br>

    <label for="gunRotX">Rot X: <span id="gunRotX-value">0</span></label><br>
    <input type="range" id="gunRotX" min="-180" max="180" value="0" style="width:100%;"><br>

    <label for="gunRotY">Rot Y: <span id="gunRotY-value">0</span></label><br>
    <input type="range" id="gunRotY" min="-180" max="180" value="0" style="width:100%;"><br>

    <label for="gunRotZ">Rot Z: <span id="gunRotZ-value">0</span></label><br>
    <input type="range" id="gunRotZ" min="-180" max="180" value="0" style="width:100%;">
  </div>

  <!-- Barrel Tab -->
  <div class="tab-content" id="tab-barrel" style="padding: 10px; display: none;">
    <div style="margin-bottom:8px;">
      <b style="font-size:10px;">Edit Position:</b>
      <button id="barrelEditADS" style="padding:2px 8px;margin-left:5px;background:#4CAF50;color:white;border:none;cursor:pointer;">ADS</button>
      <button id="barrelEditHip" style="padding:2px 8px;margin-left:5px;background:#555;color:white;border:none;cursor:pointer;">Hip</button>
      <span id="barrelEditModeLabel" style="margin-left:10px;font-size:10px;color:#4CAF50;">[Editing ADS]</span>
    </div>

    <label for="barrelYaw">Barrel Yaw: <span id="barrelYaw-value">0</span>Â°</label><br>
    <input type="range" id="barrelYaw" min="-45" max="45" value="0" style="width:100%;"><br>

    <hr style="border-color:#555;margin:8px 0;">
    <b style="font-size:10px;">Barrel Tip (gun-relative):</b><br>
    <label for="barrelX">Forward: <span id="barrelX-value">0.26</span></label><br>
    <input type="range" id="barrelX" min="-0.5" max="0.5" step="0.01" value="0.26" style="width:100%;"><br>

    <label for="barrelY">Up: <span id="barrelY-value">0.08</span></label><br>
    <input type="range" id="barrelY" min="-0.3" max="0.3" step="0.01" value="0.08" style="width:100%;"><br>

    <label for="barrelZ">Right: <span id="barrelZ-value">0</span></label><br>
    <input type="range" id="barrelZ" min="-0.3" max="0.3" step="0.01" value="0" style="width:100%;"><br>

    <hr style="border-color:#555;margin:8px 0;">
    <b style="font-size:10px;">Gun World Offset:</b><br>
    <label for="gunWorldFwd">Forward: <span id="gunWorldFwd-value">10</span></label><br>
    <input type="range" id="gunWorldFwd" min="0" max="50" value="10" style="width:100%;"><br>

    <label for="gunWorldRight">Right: <span id="gunWorldRight-value">15</span></label><br>
    <input type="range" id="gunWorldRight" min="-30" max="30" value="15" style="width:100%;"><br>

    <label for="gunWorldDown">Down: <span id="gunWorldDown-value">8</span></label><br>
    <input type="range" id="gunWorldDown" min="-20" max="30" value="8" style="width:100%;">
  </div>

  <!-- UI Tab -->
  <div class="tab-content" id="tab-ui" style="padding: 10px; display: none;">
    <b style="font-size:10px;">Master Scale:</b><br>
    <label for="uiScaleAll">All UI: <span id="uiScaleAll-value">1.0</span>x</label><br>
    <input type="range" id="uiScaleAll" min="0.5" max="2.0" step="0.1" value="1.0" style="width:100%;"><br>

    <hr style="border-color:#555;margin:8px 0;">
    <b style="font-size:10px;">Individual Scales:</b><br>

    <label for="uiScaleCrosshair">Crosshair: <span id="uiScaleCrosshair-value">1.0</span>x</label><br>
    <input type="range" id="uiScaleCrosshair" min="0.5" max="3.0" step="0.1" value="1.0" style="width:100%;"><br>

    <label for="uiScaleHealthbar">Health Bar: <span id="uiScaleHealthbar-value">1.0</span>x</label><br>
    <input type="range" id="uiScaleHealthbar" min="0.5" max="2.0" step="0.1" value="1.0" style="width:100%;"><br>

    <label for="uiScaleJumpbar">Jump Bar: <span id="uiScaleJumpbar-value">1.0</span>x</label><br>
    <input type="range" id="uiScaleJumpbar" min="0.5" max="2.0" step="0.1" value="1.0" style="width:100%;"><br>

    <label for="uiScaleMinimap">Minimap: <span id="uiScaleMinimap-value">1.0</span>x</label><br>
    <input type="range" id="uiScaleMinimap" min="0.5" max="2.0" step="0.1" value="1.0" style="width:100%;"><br>

    <label for="minimapZoomRange">Minimap Zoom: <span id="minimapZoomRange-value">200</span> (Z key)</label><br>
    <input type="range" id="minimapZoomRange" min="10" max="300" step="10" value="200" style="width:100%;"><br>

    <label for="sideViewZoomRange">Side View Zoom: <span id="sideViewZoomRange-value">300</span> (Z key)</label><br>
    <input type="range" id="sideViewZoomRange" min="10" max="500" step="10" value="300" style="width:100%;"><br>

    <label for="uiScaleWeaponUI">Weapon UI: <span id="uiScaleWeaponUI-value">1.0</span>x</label><br>
    <input type="range" id="uiScaleWeaponUI" min="0.5" max="2.0" step="0.1" value="1.0" style="width:100%;"><br>

    <hr style="border-color:#555;margin:8px 0;">
    <b style="font-size:10px;">Sniper Scope Mode:</b><br>
    <div style="margin-top:5px;">
      <button id="scopeModeForward" style="padding:4px 8px;background:#4CAF50;color:white;border:none;cursor:pointer;font-size:10px;">Forward Position</button>
      <button id="scopeModeFocal" style="padding:4px 8px;background:#555;color:white;border:none;cursor:pointer;font-size:10px;">Focal Length</button>
    </div>
    <div id="scopeModeDesc" style="margin-top:5px;font-size:9px;color:#888;">Camera moves forward (may clip through walls)</div>
  </div>

  <!-- GMD (Gun Mechanics Debug) Tab -->
  <div class="tab-content" id="tab-gmd" style="padding: 10px; display: none;">
    <b style="font-size:11px; color:#00ff00;">Gun Mechanics Debug</b><br><br>
    <label style="font-size:11px;"><input type="checkbox" id="showGMD" checked> Show debug overlay</label><br><br>
    <label style="font-size:11px;"><input type="checkbox" id="showTestTarget" checked> Enable test target</label><br><br>
    <label style="font-size:11px;"><input type="checkbox" id="showMinimaps" checked> Show minimaps &amp; legend</label><br><br>

    <b style="font-size:10px; color:#ffff00;">Target Controls</b><br>
    <label for="targetDistance">Distance: <span id="targetDistance-value">25</span></label><br>
    <input type="range" id="targetDistance" min="5" max="200" value="25" style="width:100%;"><br>

    <label for="targetRadius">Radius: <span id="targetRadius-value">2.0</span></label><br>
    <input type="range" id="targetRadius" min="0.5" max="10" step="0.5" value="2" style="width:100%;"><br>

    <button id="resetHitCount" style="margin-top:8px;padding:4px 10px;background:#555;color:white;border:none;cursor:pointer;">Reset Hit/Miss Count</button>
  </div>

  <!-- Debug Tab -->
  <div class="tab-content" id="tab-debug" style="padding: 10px; display: none; font-size: 11px;">
    <b>FPS:</b> <span id="debug-fps">0</span><br>
    <b>Bullets:</b> <span id="debug-bulletcount">0</span><br>
    <hr style="border-color:#555;margin:5px 0;">
    <b>Player Position:</b><br>
    <span id="debug-playerposition">-</span><br>
    <b>Player Rotation:</b><br>
    <span id="debug-playerrotation">-</span><br>
    <hr style="border-color:#555;margin:5px 0;">
    <b>Last Bullet Pos:</b><br>
    <span id="debug-lastbulletpos">-</span><br>
    <b>Last Bullet Screen:</b><br>
    <span id="debug-lastbulletscreen">-</span><br>
    <b>Destroyed Pos:</b><br>
    <span id="debug-lastbulletdestroyedpos">-</span><br>
    <b>Destroyed Reason:</b><br>
    <span id="debug-lastbulletdestroyedreason">-</span>
  </div>

  <!-- Save/Reset Buttons -->
  <div style="padding: 10px; border-top: 1px solid #555; display: flex; gap: 10px;">
    <button id="saveSettings" style="flex:1; padding:8px; background:#2a6; color:white; border:none; border-radius:4px; cursor:pointer;">Save</button>
    <button id="resetSettings" style="flex:1; padding:8px; background:#a62; color:white; border:none; border-radius:4px; cursor:pointer;">Reset</button>
  </div>
</div>
    
<!-- Game Container - holds canvas and all HUD elements -->
<div id="game-container">
    <canvas id="fullscreenCanvas" width="800" height="450"></canvas>

    <div id="crosshair"></div>
    <div id="healthbar">
        <div id="health"></div>
        <div class="hud-item" style="background-image: url('images/heart.png');"></div>
    </div>
    <div id="jumpbar">
        <div id="jumpcharge"></div>
    </div>
</div>

<!-- Debug elements (hidden) -->
<div id="fps"></div>
<div id="lastbulletdestroyedreason"></div>
<div id="lastbulletdestroyedpos"></div>
<div id="lastbulletpos"></div>
<div id="lastbulletscreen"></div>
<div id="playerrotation"></div>
<div id="playerposition"></div>
<div id="bulletcount"></div>
<div id="info">Keyboard: WASD move, Mouse look, LMB shoot, RMB toggle ADS, HOLD Space jump, Shift sprint, C crouch, R reload, Q swap weapon, E pickup | Gamepad: Left Stick move, Right Stick look, RT shoot, LT toggle ADS, HOLD LB jump, B crouch, X reload, Y swap weapon, L3/A sprint</div>

<!-- Modules (JS with functions) -->
<script src="modules/displayConfig.js"></script>
<script src="modules/weaponConfig.js"></script>
<script src="modules/scopeForwardPosition.js"></script>
<script src="modules/scopeFocalLength.js"></script>

<script>
"use strict";

// Polyfill for roundRect (not available in all browsers)
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    };
}

// ===============================
// JSON Config Loader
// ===============================
var ConfigLoader = {
    loaded: false,
    settings: null,
    gunModel: null,
    weapons: null,
    display: null,

    // Load all JSON configs
    loadAll: async function() {
        try {
            const [settings, gunModelData, weapons, display] = await Promise.all([
                fetch('data/settings.json').then(r => r.json()).catch(() => null),
                fetch('data/gunModel.json').then(r => r.json()).catch(() => null),
                fetch('data/weapons.json').then(r => r.json()).catch(() => null),
                fetch('data/display.json').then(r => r.json()).catch(() => null)
            ]);

            this.settings = settings;
            this.gunModel = gunModelData;
            this.weapons = weapons;
            this.display = display;
            this.loaded = true;

            console.log('JSON configs loaded from data/ folder');
            return true;
        } catch (error) {
            console.log('Could not load JSON configs:', error);
            return false;
        }
    },

    // Apply loaded settings to game state
    applyGunModel: function(gm) {
        if (!this.gunModel || !gm) return;
        var data = this.gunModel;

        // ADS settings
        if (data.ads) {
            gm.adsOffsetX = data.ads.offsetX;
            gm.adsOffsetY = data.ads.offsetY;
            gm.adsOffsetZ = data.ads.offsetZ;
            gm.adsScale = data.ads.scale;
            gm.adsRotationX = data.ads.rotationX;
            gm.adsRotationY = data.ads.rotationY;
            gm.adsRotationZ = data.ads.rotationZ;
        }

        // Hip settings
        if (data.hip) {
            gm.hipOffsetX = data.hip.offsetX;
            gm.hipOffsetY = data.hip.offsetY;
            gm.hipOffsetZ = data.hip.offsetZ;
            gm.hipScale = data.hip.scale;
            gm.hipRotationX = data.hip.rotationX;
            gm.hipRotationY = data.hip.rotationY;
            gm.hipRotationZ = data.hip.rotationZ;
        }

        // Barrel settings (support both old single format and new ads/hip format)
        if (data.barrel) {
            // Check for new ADS/Hip barrel format
            if (data.barrel.ads) {
                gm.adsBarrelX = data.barrel.ads.x;
                gm.adsBarrelY = data.barrel.ads.y;
                gm.adsBarrelZ = data.barrel.ads.z;
                gm.adsBarrelYaw = data.barrel.ads.yaw || 0;
            } else {
                // Old format - apply to ADS
                gm.adsBarrelX = data.barrel.x;
                gm.adsBarrelY = data.barrel.y;
                gm.adsBarrelZ = data.barrel.z;
                gm.adsBarrelYaw = data.barrel.yaw || 0;
            }

            if (data.barrel.hip) {
                gm.hipBarrelX = data.barrel.hip.x;
                gm.hipBarrelY = data.barrel.hip.y;
                gm.hipBarrelZ = data.barrel.hip.z;
                gm.hipBarrelYaw = data.barrel.hip.yaw || 0;
            } else {
                // Old format - use same as ADS for hip
                gm.hipBarrelX = gm.adsBarrelX;
                gm.hipBarrelY = gm.adsBarrelY;
                gm.hipBarrelZ = gm.adsBarrelZ;
                gm.hipBarrelYaw = gm.adsBarrelYaw;
            }

            gm.barrelDistance = data.barrel.distance;
        }

        // World settings (support both old single format and new ads/hip format)
        if (data.world) {
            if (data.world.ads) {
                gm.adsWorldForward = data.world.ads.forward;
                gm.adsWorldRight = data.world.ads.right;
                gm.adsWorldDown = data.world.ads.down;
            } else {
                // Old format - apply to ADS
                gm.adsWorldForward = data.world.forward;
                gm.adsWorldRight = data.world.right;
                gm.adsWorldDown = data.world.down;
            }

            if (data.world.hip) {
                gm.hipWorldForward = data.world.hip.forward;
                gm.hipWorldRight = data.world.hip.right;
                gm.hipWorldDown = data.world.hip.down;
            } else {
                // Old format - use same as ADS for hip
                gm.hipWorldForward = gm.adsWorldForward;
                gm.hipWorldRight = gm.adsWorldRight;
                gm.hipWorldDown = gm.adsWorldDown;
            }
        }

        if (data.adsLerpSpeed) gm.adsLerpSpeed = data.adsLerpSpeed;

        console.log('Applied gun model settings from JSON');
    },

    // Apply weapon data to WeaponConfig
    applyWeapons: function() {
        if (!this.weapons || typeof WeaponConfig === 'undefined') return;
        WeaponConfig.weapons = this.weapons;
        console.log('Applied weapons config from JSON');
    },

    // Generate JSON for export (for Save button)
    exportSettings: function(gm) {
        return {
            settings: {
                camera: {
                    fov: camera.baseFocalLength,
                    pitchOffset: typeof pitchOffset !== 'undefined' ? pitchOffset : 0,
                    targetFPS: typeof targetFPS !== 'undefined' ? targetFPS : 60
                },
                player: {
                    playerHeight: typeof playerHeightOffset !== 'undefined' ? playerHeightOffset : 80,
                    normalHeight: typeof player !== 'undefined' ? player.normalHeight : 80,
                    crouchHeight: typeof player !== 'undefined' ? player.crouchHeight : 40,
                    jumpMin: typeof player !== 'undefined' ? player.jumpMinStrength : 10,
                    jumpMax: typeof player !== 'undefined' ? player.jumpMaxStrength : 25
                },
                bullet: {
                    bulletSize: typeof bulletSize !== 'undefined' ? bulletSize : 2.0,
                    barrelDistance: gm.barrelDistance
                },
                minimap: {
                    zoomRange: typeof minimapZoomRange !== 'undefined' ? minimapZoomRange : 200,
                    sideViewZoomRange: typeof sideViewZoomRange !== 'undefined' ? sideViewZoomRange : 300
                },
                scope: {
                    mode: typeof scopeMode !== 'undefined' ? scopeMode : 'crop'
                },
                debug: {
                    showHitRanges: typeof showHitRanges !== 'undefined' ? showHitRanges : true,
                    showGMD: typeof showGMD !== 'undefined' ? showGMD : true,
                    showTestTarget: typeof testTarget !== 'undefined' ? testTarget.enabled : true,
                    targetDistance: typeof testTarget !== 'undefined' ? testTarget.distance : 25,
                    targetRadius: typeof testTarget !== 'undefined' ? testTarget.radius : 2.0
                }
            },
            gunModel: {
                ads: {
                    offsetX: gm.adsOffsetX,
                    offsetY: gm.adsOffsetY,
                    offsetZ: gm.adsOffsetZ,
                    scale: gm.adsScale,
                    rotationX: gm.adsRotationX,
                    rotationY: gm.adsRotationY,
                    rotationZ: gm.adsRotationZ
                },
                hip: {
                    offsetX: gm.hipOffsetX,
                    offsetY: gm.hipOffsetY,
                    offsetZ: gm.hipOffsetZ,
                    scale: gm.hipScale,
                    rotationX: gm.hipRotationX,
                    rotationY: gm.hipRotationY,
                    rotationZ: gm.hipRotationZ
                },
                barrel: {
                    ads: {
                        x: gm.adsBarrelX,
                        y: gm.adsBarrelY,
                        z: gm.adsBarrelZ,
                        yaw: gm.adsBarrelYaw
                    },
                    hip: {
                        x: gm.hipBarrelX,
                        y: gm.hipBarrelY,
                        z: gm.hipBarrelZ,
                        yaw: gm.hipBarrelYaw
                    },
                    distance: gm.barrelDistance
                },
                world: {
                    ads: {
                        forward: gm.adsWorldForward,
                        right: gm.adsWorldRight,
                        down: gm.adsWorldDown
                    },
                    hip: {
                        forward: gm.hipWorldForward,
                        right: gm.hipWorldRight,
                        down: gm.hipWorldDown
                    }
                },
                adsLerpSpeed: gm.adsLerpSpeed
            }
        };
    },

    // Copy JSON to clipboard for manual file update
    copyToClipboard: function(gm) {
        var exported = this.exportSettings(gm);
        var jsonStr = JSON.stringify(exported, null, 2);

        navigator.clipboard.writeText(jsonStr).then(function() {
            console.log('Settings JSON copied to clipboard!');
            console.log('Paste into data/settings.json and data/gunModel.json');
        }).catch(function(err) {
            console.error('Failed to copy:', err);
            // Fallback: log to console
            console.log('=== SETTINGS JSON ===');
            console.log(JSON.stringify(exported.settings, null, 2));
            console.log('=== GUN MODEL JSON ===');
            console.log(JSON.stringify(exported.gunModel, null, 2));
        });

        return exported;
    }
};

var camera = {
    x: 0, y: 0, height: 78, angle: 0, horizon: 100,
    distance: 2000, velocityY: 0,
    baseFocalLength: 300,  // normal FOV
    focalLength: 300,      // current focal length
    // ADS camera offset (moves camera forward for zoom effect)
    adsOffset: 0,          // current offset
    baseX: 0, baseY: 0     // actual player position (before ADS offset)
};

var player={health:100,isCrouching:false,moveSpeed:1.5,sprintMultiplier:2,
            // Charged jump system
            jumpMinStrength:3,      // tap jump
            jumpMaxStrength:12,     // fully charged (basketball player ~1m vertical)
            jumpChargeTime:0,       // current charge time in ms
            jumpMaxChargeTime:1000, // 1 second to fully charge
            isChargingJump:false,
            crouchHeight:40,normalHeight:78,
            // Weapon state
            wasSwapping:false,wasPickingUp:false,wasShooting:false},

    // Weapon definitions
    weapons = {
        testgun: {
            name: "Test Gun",
            letter: "T",
            color: "#00FFFF",      // Cyan
            bgColor: "#008888",
            magazine: Infinity,
            maxMagazine: Infinity,
            reloadTime: 0,
            fireRate: 100,
            fireMode: "auto",
            damage: 50,
            bulletSpeed: 15,
            adsZoom: 1.5,
            useScope: true         // Has picture-in-picture scope for testing
        },
        rifle: {
            name: "Rifle",
            letter: "R",
            color: "#8B00FF",      // Purple
            bgColor: "#4B0082",
            magazine: 30,
            maxMagazine: 30,
            reloadTime: 2000,
            fireRate: 100,         // Fast auto fire
            fireMode: "auto",
            damage: 15,
            bulletSpeed: 12,
            adsZoom: 1.8           // 1.8x zoom when aiming
        },
        pistol: {
            name: "Pistol",
            letter: "P",
            color: "#C0C0C0",      // Silver
            bgColor: "#808080",
            magazine: 12,
            maxMagazine: 12,
            reloadTime: 1000,
            fireRate: 200,         // Semi-auto
            fireMode: "semi",
            damage: 25,
            bulletSpeed: 10,
            adsZoom: 1.3           // 1.3x zoom (minimal for pistol)
        },
        sniper: {
            name: "Sniper",
            letter: "S",
            color: "#228B22",      // Forest green
            bgColor: "#006400",
            magazine: 5,
            maxMagazine: 5,
            reloadTime: 3000,
            fireRate: 1000,        // Slow but powerful
            fireMode: "semi",
            damage: 100,
            bulletSpeed: 20,
            adsZoom: 4.0,          // 4x scope zoom (base)
            useScope: true,        // Has picture-in-picture scope
            ccdOnly: true          // No hitscan, CCD only for realistic bullet travel
        }
    },

    // Player's current weapons (2 slots)
    playerWeapons = [
        { type: "testgun", ammo: Infinity, isReloading: false, lastShot: 0 },
        { type: "sniper", ammo: 5, isReloading: false, lastShot: 0 }
    ],
    currentWeaponIndex = 0,  // Which weapon is active (0 or 1)
    prevSwapButton = false,  // For edge detection on Y button

    // Weapons on ground
    groundWeapons = [],
    nearbyWeapon = null,     // Weapon player can pick up

    // Legacy gun object for compatibility
    gun={magazine:200,maxMagazine:200,reloadTime:1000,isReloading:false,lastShot:0,fireRate:300},
    items=[], // unified bullets + hearts + pickups
    lastBullet=null,lastBulletDestroyedPos=null,lastBulletDestroyedReason=null,lastBulletScreen=null,
    map={width:1024,height:1024,shift:10,altitude:new Uint8Array(1024*1024),color:new Uint32Array(1024*1024)},
    screendata={canvas:null,context:null,imagedata:null,bufarray:null,buf8:null,buf32:null,backgroundcolor:0xFFE09090,depthBuffer:null},
    input={forward:false,backward:false,left:false,right:false,jump:false,sprint:false,crouch:false,shoot:false,reload:false,aim:false,mouseX:0,mouseY:0,
           // Gamepad analog values (for smooth movement)
           moveX:0,moveY:0,lookX:0,lookY:0,
           // Gamepad button states (separate from keyboard/mouse)
           gpShoot:false,gpAim:false,gpCrouch:false,gpSprint:false,gpReload:false,gpJumpHeld:false,
           // Weapon controls
           swapWeapon:false,gpSwapWeapon:false,pickupWeapon:false,gpPickupWeapon:false,
           // ADS toggle state
           aimToggled:false,prevGpAim:false},
    // Mobile touch controls
    touchControls = {
        enabled: false,        // Auto-enabled on touch devices
        leftStick: { active: false, touchId: null, startX: 0, startY: 0, currentX: 0, currentY: 0 },
        rightStick: { active: false, touchId: null, startX: 0, startY: 0, currentX: 0, currentY: 0 },
        stickRadius: 50,       // Radius of joystick circle
        stickDeadzone: 10,     // Deadzone before input registers
        leftStickPos: { x: 100, y: 0 },   // Will be set based on screen size
        rightStickPos: { x: 0, y: 0 },    // Will be set based on screen size
        weaponSlots: [],       // Hitboxes for weapon icons [{x, y, w, h, index}]
        pickupHitbox: null,    // Hitbox for pickup prompt
        shootButton: { x: 0, y: 0, radius: 40, active: false, touchId: null }
    },
    debugUIVisible=true,  // Toggle with Start button
    playerHeightOffset=30, // Player eye height above terrain (min 30)
    bulletVertOffset=0,    // Vertical offset for bullet spawn (negative = below eye level)
    bulletFwdOffset=0,     // Forward offset for bullet spawn (weapon distance from camera)
    bulletHorizOffset=0,   // Horizontal offset for bullet spawn (left/right)
    bulletSize=0.75,       // Bullet rendering scale
    // Hitscan/CCD hybrid system
    hitscanDistance=50,    // Distance for instant hitscan (world units)
    ccdMaxDistance=500,    // Max distance for CCD bullets before despawn
    showHitRanges=true,    // Show hitscan/CCD radius circles on minimap
    showGMD=true,          // Show Gun Mechanics Debug overlay
    showMinimaps=true,     // Show minimaps and legend overlays
    minimapZoomRange=200,  // Minimap zoom range in world units (10-300)
    sideViewZoomRange=300, // Side view zoom range in world units (10-500)
    // Sniper scope mode - modular scope system
    // Options: ScopeForwardPosition (camera ahead) or ScopeFocalLength (same pos, zoom FOV)
    scopeMode = 'forward',  // 'forward' or 'focal'
    activeScope = null,     // Will be set to ScopeForwardPosition or ScopeFocalLength
    // UI Scale settings
    uiScale={
        all: 1.0,
        crosshair: 1.0,
        healthbar: 1.0,
        jumpbar: 1.0,
        minimap: 1.0,
        weaponUI: 1.0
    },
    gamepad={
        connected:false,
        deadzone:0.15,
        lookSensitivity:0.05,
        // Previous button states for edge detection
        prevJump:false,
        prevStart:false,
        // Standard gamepad mapping (Xbox-style, works with most controllers)
        buttons:{
            jump:4,        // LB (Left Bumper) - hold to charge, release to jump
            crouch:1,      // B
            reload:2,      // X
            sprint:10,     // Left Stick Click
            sprintAlt:0,   // A button (alternative sprint)
            shoot:7,       // RT (Right Trigger as button)
            aim:6,         // LT (Left Trigger as button)
            start:9,       // Start button - toggle debug UI
            swapWeapon:3,  // Y button - swap weapons
            pickup:2       // X button - also pickup (context sensitive)
        },
        axes:{
            moveX:0,       // Left Stick X
            moveY:1,       // Left Stick Y
            lookX:2,       // Right Stick X
            lookY:3        // Right Stick Y
        }
    },
    updaterunning=false,time=Date.now(),timelastframe=Date.now(),frames=0,pitchOffset=250,targetFPS=60,frameDuration=1000/targetFPS,lastFrameTime=0,hiddeny;

// ===============================
// Item textures
var textures = {
    bullet: (() => { let i = new Image(); i.src = "images/bullet.png"; return i; })(),
    heart:  (() => { let i = new Image(); i.src = "images/heart.png";  return i; })(),
    tree:   (() => { let i = new Image(); i.src = "images/tree.png";   return i; })() // NEW
};

// ===============================
// 3D Cube - Blue, 100 units tall, placed near player start
var cube = {
    x: 80,      // world X position (not far from player start at 0,0)
    y: 80,      // world Y position
    z: 0,       // base height (will sit on terrain)
    size: 100,  // 100 feet/units tall (and wide/deep)
    color: 0xFF0000FF  // Blue in ABGR format
};

// Get cube vertices in world space (8 corners of a cube)
function getCubeVertices() {
    var s = cube.size;
    var baseZ = getRawTerrainHeight(cube.x, cube.y);  // Sit on terrain
    return [
        // Bottom face (z = baseZ)
        {x: cube.x - s/2, y: cube.y - s/2, z: baseZ},       // 0: back-left-bottom
        {x: cube.x + s/2, y: cube.y - s/2, z: baseZ},       // 1: back-right-bottom
        {x: cube.x + s/2, y: cube.y + s/2, z: baseZ},       // 2: front-right-bottom
        {x: cube.x - s/2, y: cube.y + s/2, z: baseZ},       // 3: front-left-bottom
        // Top face (z = baseZ + size)
        {x: cube.x - s/2, y: cube.y - s/2, z: baseZ + s},   // 4: back-left-top
        {x: cube.x + s/2, y: cube.y - s/2, z: baseZ + s},   // 5: back-right-top
        {x: cube.x + s/2, y: cube.y + s/2, z: baseZ + s},   // 6: front-right-top
        {x: cube.x - s/2, y: cube.y + s/2, z: baseZ + s}    // 7: front-left-top
    ];
}

// Project a 3D point to screen coordinates
// Must match RenderItems projection exactly to avoid shifting
function projectPoint(p) {
    var dx = p.x - camera.x;
    var dy = p.y - camera.y;

    // Use precomputed trig values from RenderCube
    var sinYaw = cubeSinYaw;
    var cosYaw = cubeCosYaw;

    // Ground-plane distance (same as RenderItems uses)
    var groundForward = -dx * sinYaw - dy * cosYaw;

    // Check if behind camera
    if (groundForward < 1) return null;

    var sw = screendata.canvas.width;

    // Right offset (same as RenderItems)
    var right = dx * cosYaw - dy * sinYaw;

    // Use same projection formula as RenderItems
    return {
        x: right * (sw / 2) / groundForward + sw / 2,
        y: (camera.height - p.z) * camera.focalLength / groundForward + camera.horizon,
        depth: groundForward
    };
}

// Draw a filled quad (4 vertices) into the pixel buffer with depth testing
function drawFilledQuad(v0, v1, v2, v3, color) {
    var sw = screendata.canvas.width;
    var sh = screendata.canvas.height;
    var buf32 = screendata.buf32;
    var depth = screendata.depthBuffer;

    // Project all vertices
    var p0 = projectPoint(v0);
    var p1 = projectPoint(v1);
    var p2 = projectPoint(v2);
    var p3 = projectPoint(v3);

    // Skip if any vertex is behind camera
    if (!p0 || !p1 || !p2 || !p3) return;

    // Backface culling - check if face is facing away from camera
    // Calculate 2D cross product of two edges in screen space
    var ax = p1.x - p0.x, ay = p1.y - p0.y;
    var bx = p2.x - p0.x, by = p2.y - p0.y;
    var cross = ax * by - ay * bx;
    // Skip culling for now to debug the door effect
    // if (cross < 0) return;

    // Get bounding box
    var minX = Math.max(0, Math.floor(Math.min(p0.x, p1.x, p2.x, p3.x)));
    var maxX = Math.min(sw - 1, Math.ceil(Math.max(p0.x, p1.x, p2.x, p3.x)));
    var minY = Math.max(0, Math.floor(Math.min(p0.y, p1.y, p2.y, p3.y)));
    var maxY = Math.min(sh - 1, Math.ceil(Math.max(p0.y, p1.y, p2.y, p3.y)));

    if (minX > maxX || minY > maxY) return;

    // Extract RGB and convert to ABGR for buffer
    var r = color & 0xFF;
    var g = (color >> 8) & 0xFF;
    var b = (color >> 16) & 0xFF;

    // Apply simple shading based on average depth
    var avgDepth = (p0.depth + p1.depth + p2.depth + p3.depth) / 4;
    var shade = Math.max(0.3, Math.min(1.0, 1.0 - avgDepth / 1000));
    r = Math.floor(r * shade);
    g = Math.floor(g * shade);
    b = Math.floor(b * shade);

    var pixelColor = 0xFF000000 | (b << 16) | (g << 8) | r;

    // Use average depth for the entire face, with small bias to avoid z-fighting
    var faceDepth = (p0.depth + p1.depth + p2.depth + p3.depth) / 4 - 0.5;

    // Helper to check if point is inside quad using cross products
    function isInsideQuad(px, py) {
        function cross(ax, ay, bx, by) { return ax * by - ay * bx; }
        var c0 = cross(p1.x - p0.x, p1.y - p0.y, px - p0.x, py - p0.y);
        var c1 = cross(p2.x - p1.x, p2.y - p1.y, px - p1.x, py - p1.y);
        var c2 = cross(p3.x - p2.x, p3.y - p2.y, px - p2.x, py - p2.y);
        var c3 = cross(p0.x - p3.x, p0.y - p3.y, px - p3.x, py - p3.y);
        return (c0 >= 0 && c1 >= 0 && c2 >= 0 && c3 >= 0) ||
               (c0 <= 0 && c1 <= 0 && c2 <= 0 && c3 <= 0);
    }

    // Rasterize the quad
    for (var py = minY; py <= maxY; py++) {
        for (var px = minX; px <= maxX; px++) {
            if (!isInsideQuad(px + 0.5, py + 0.5)) continue;

            var bufIdx = py * sw + px;

            // Depth test - only draw if in front of existing pixel
            if (faceDepth < depth[bufIdx]) {
                buf32[bufIdx] = pixelColor;
                depth[bufIdx] = faceDepth;
            }
        }
    }
}

// Precomputed trig values for current frame (set in RenderCube)
var cubeSinYaw = 0, cubeCosYaw = 0;

// ===============================
// Gun Viewmodel (first-person weapon)
var gunModel = {
    vertices: [],      // Array of {x, y, z}
    faces: [],         // Array of vertex indices
    loaded: false,
    texture: null,
    // Current interpolated position (updated each frame)
    offsetX: 100,      // pixels from right
    offsetY: 50,       // pixels from bottom
    offsetZ: 0,        // depth offset
    scale: 300,        // rendering scale
    rotationX: 0,      // X-axis rotation in degrees
    rotationY: 0,      // Y-axis rotation in degrees
    rotationZ: 0,      // Z-axis rotation in degrees

    // ADS (Aim Down Sights) position - gun raised to eye level
    adsOffsetX: 0,     // centered for iron sights
    adsOffsetY: 100,   // raised up
    adsOffsetZ: 0,
    adsScale: 350,
    adsRotationX: 0,
    adsRotationY: 0,
    adsRotationZ: 0,

    // Hip fire position - gun held at hip/chest level
    hipOffsetX: 100,   // offset to the right
    hipOffsetY: 50,    // lower position
    hipOffsetZ: 0,
    hipScale: 300,
    hipRotationX: 0,
    hipRotationY: 0,
    hipRotationZ: 0,

    // Interpolation factor (0 = hip, 1 = ADS)
    adsLerp: 0,
    adsLerpSpeed: 0.15,  // how fast to transition

    // Barrel configuration (gun-relative: forward/up/right along gun direction)
    // Current/interpolated values (updated each frame based on adsLerp)
    barrelX: 0.26,     // forward along gun barrel
    barrelY: 0.08,     // up from gun center
    barrelZ: 0.0,      // right from gun center
    barrelYaw: 0,      // horizontal aim offset in degrees (left/right)

    // ADS barrel settings
    adsBarrelX: 0.26,
    adsBarrelY: 0.08,
    adsBarrelZ: 0.0,
    adsBarrelYaw: 0,

    // Hip barrel settings
    hipBarrelX: 0.26,
    hipBarrelY: 0.08,
    hipBarrelZ: 0.0,
    hipBarrelYaw: 0,

    barrelDistance: 5, // world units in front of barrel to spawn bullet

    // World-space offset from camera (where gun is held)
    // Current/interpolated values (updated each frame based on adsLerp)
    worldForward: 10,  // how far forward from camera
    worldRight: 15,    // how far right from camera
    worldDown: 8,      // how far down from camera eye level

    // ADS world offset settings
    adsWorldForward: 10,
    adsWorldRight: 15,
    adsWorldDown: 8,

    // Hip world offset settings
    hipWorldForward: 10,
    hipWorldRight: 15,
    hipWorldDown: 8,

    // Pivot mode: 'barrel' for ADS (pivot at bullet spawn), 'grip' for hip fire
    pivotMode: 'grip'  // current pivot mode
};

// ===============================
// Test Target - floating circle for gun mechanics testing
var testTarget = {
    enabled: true,
    x: 0,           // world X position (will be set relative to player)
    y: 0,           // world Y position
    z: 0,           // world Z position (height)
    radius: 2,      // target radius in world units
    distance: 30,   // distance from player to spawn target
    color: '#ff0000',
    ringColor: '#ffffff',
    // Calculated each frame
    playerDistance: 0,
    angleToTarget: 0,    // horizontal angle difference
    pitchToTarget: 0,    // vertical angle to target
    aimError: 0,         // how far off aim is from target center
    bulletHitPos: null,  // last bullet impact position relative to target
    hits: 0,
    misses: 0
};

// Position target in front of player at eye level
function positionTestTarget() {
    var fx = -Math.sin(camera.angle);
    var fy = -Math.cos(camera.angle);
    testTarget.x = camera.x + fx * testTarget.distance;
    testTarget.y = camera.y + fy * testTarget.distance;
    testTarget.z = camera.height; // at eye level
}

// Calculate gun mechanics data relative to target
function updateTargetMetrics() {
    if (!testTarget.enabled) return;

    var dx = testTarget.x - camera.x;
    var dy = testTarget.y - camera.y;
    var dz = testTarget.z - camera.height;

    // Distance to target
    testTarget.playerDistance = Math.sqrt(dx*dx + dy*dy + dz*dz);
    var horizDist = Math.sqrt(dx*dx + dy*dy);

    // Angle to target (horizontal)
    var targetAngle = Math.atan2(-dx, -dy); // same convention as camera.angle
    testTarget.angleToTarget = (targetAngle - camera.angle) * 180 / Math.PI;
    // Normalize to -180 to 180
    while (testTarget.angleToTarget > 180) testTarget.angleToTarget -= 360;
    while (testTarget.angleToTarget < -180) testTarget.angleToTarget += 360;

    // Pitch to target
    testTarget.pitchToTarget = Math.atan2(dz, horizDist) * 180 / Math.PI;

    // Current aim direction
    var cameraPitch = horizonToPitchRad(camera.horizon - pitchOffset) * 180 / Math.PI;

    // Aim error (difference between where we're aiming and where target is)
    var aimHorizError = testTarget.angleToTarget; // how far left/right of crosshair
    var aimVertError = testTarget.pitchToTarget - cameraPitch; // how far up/down of crosshair
    testTarget.aimError = Math.sqrt(aimHorizError*aimHorizError + aimVertError*aimVertError);
}

// Get the gun's forward direction in world space (based on gun rotation + camera angle)
function getGunWorldDirection() {
    var rotX = gunModel.rotationX * Math.PI / 180;
    var rotY = gunModel.rotationY * Math.PI / 180;
    var rotZ = gunModel.rotationZ * Math.PI / 180;

    var cosX = Math.cos(rotX), sinX = Math.sin(rotX);
    var cosY = Math.cos(rotY), sinY = Math.sin(rotY);
    var cosZ = Math.cos(rotZ), sinZ = Math.sin(rotZ);

    // Gun's forward is +X in model space
    var x = 1, y = 0, z = 0;

    // Apply same rotations as rendering
    var y1 = y * cosX - z * sinX;
    var z1 = y * sinX + z * cosX;
    var x2 = x * cosY + z1 * sinY;
    var z2 = -x * sinY + z1 * cosY;
    var x3 = x2 * cosZ - y1 * sinZ;
    var y3 = x2 * sinZ + y1 * cosZ;

    // x3 = screen right, y3 = screen up, z2 = screen depth (into screen)
    // Convert screen-space direction to world-space using camera angle + barrel yaw
    var aimAngle = camera.angle + (gunModel.barrelYaw || 0) * Math.PI / 180;
    var camSin = Math.sin(aimAngle);
    var camCos = Math.cos(aimAngle);

    // World forward is -sin(angle), -cos(angle)
    // Negate all to flip bullet direction 180 degrees
    var worldX = -x3 * camCos - z2 * camSin;
    var worldY = x3 * camSin - z2 * camCos;
    var worldZ = y3;

    // Normalize
    var len = Math.sqrt(worldX*worldX + worldY*worldY + worldZ*worldZ) || 1;
    return { x: worldX/len, y: worldY/len, z: worldZ/len };
}

// Get barrel position in screen coordinates (for debug drawing)
function getBarrelScreenPos() {
    var sw = screendata.canvas.width;
    var sh = screendata.canvas.height;
    var centerX = sw - gunModel.offsetX;
    var centerY = sh - gunModel.offsetY;

    var rotX = gunModel.rotationX * Math.PI / 180;
    var rotY = gunModel.rotationY * Math.PI / 180;
    var rotZ = gunModel.rotationZ * Math.PI / 180;

    var cosX = Math.cos(rotX), sinX = Math.sin(rotX);
    var cosY = Math.cos(rotY), sinY = Math.sin(rotY);
    var cosZ = Math.cos(rotZ), sinZ = Math.sin(rotZ);

    // Gun's forward direction in screen space (after rotation)
    // Forward is +X in model space, which becomes screen right/depth after rotation
    var fwdX = 1, fwdY = 0, fwdZ = 0;
    var fy1 = fwdY * cosX - fwdZ * sinX;
    var fz1 = fwdY * sinX + fwdZ * cosX;
    var fx2 = fwdX * cosY + fz1 * sinY;
    var fz2 = -fwdX * sinY + fz1 * cosY;
    var fx3 = fx2 * cosZ - fy1 * sinZ;
    var fy3 = fx2 * sinZ + fy1 * cosZ;

    // Gun's up direction in screen space
    var upX = 0, upY = 1, upZ = 0;
    var uy1 = upY * cosX - upZ * sinX;
    var uz1 = upY * sinX + upZ * cosX;
    var ux2 = upX * cosY + uz1 * sinY;
    var uz2 = -upX * sinY + uz1 * cosY;
    var ux3 = ux2 * cosZ - uy1 * sinZ;
    var uy3 = ux2 * sinZ + uy1 * cosZ;

    // Gun's right direction in screen space
    var rtX = 0, rtY = 0, rtZ = 1;
    var ry1 = rtY * cosX - rtZ * sinX;
    var rz1 = rtY * sinX + rtZ * cosX;
    var rx2 = rtX * cosY + rz1 * sinY;
    var rz2 = -rtX * sinY + rz1 * cosY;
    var rx3 = rx2 * cosZ - ry1 * sinZ;
    var ry3 = rx2 * sinZ + ry1 * cosZ;

    // Barrel offset in gun-relative space (forward/up/right)
    var fwd = gunModel.barrelX;   // forward along gun
    var up = gunModel.barrelY;    // up from gun
    var right = gunModel.barrelZ; // right from gun

    // Combine offsets in screen space
    var screenX = fx3 * fwd + ux3 * up + rx3 * right;
    var screenY = fy3 * fwd + uy3 * up + ry3 * right;

    return {
        x: centerX + screenX * gunModel.scale,
        y: centerY - screenY * gunModel.scale
    };
}

// Get barrel position in world coordinates (for bullet spawning)
function getBarrelWorldPos() {
    // Camera direction vectors
    var camSin = Math.sin(camera.angle);
    var camCos = Math.cos(camera.angle);
    var fx = -camSin, fy = -camCos;  // forward (world)
    var rx = camCos, ry = -camSin;   // right (world)

    // Gun base position in world (offset from camera)
    var gunWorldX = camera.x + fx * gunModel.worldForward + rx * gunModel.worldRight;
    var gunWorldY = camera.y + fy * gunModel.worldForward + ry * gunModel.worldRight;
    var gunWorldZ = camera.height - gunModel.worldDown;

    // Get the direction the gun is pointing (differs based on pivot mode)
    var gunDirX, gunDirY, gunDirZ;
    if (gunModel.pivotMode === 'barrel') {
        // ADS mode: gun aims at SCREEN CENTER (where crosshair is)
        var screenCenterY = screendata.canvas.height / 2;
        var screenCenterPitch = Math.atan((camera.horizon - screenCenterY) / camera.focalLength);
        var cosPitch = Math.cos(screenCenterPitch);
        var sinPitch = Math.sin(screenCenterPitch);
        gunDirX = fx * cosPitch;
        gunDirY = fy * cosPitch;
        gunDirZ = sinPitch;
    } else {
        // Hip fire mode: use gun's own rotation
        var gunDir = getGunWorldDirection();
        gunDirX = gunDir.x;
        gunDirY = gunDir.y;
        gunDirZ = gunDir.z;
    }

    // Calculate up and right vectors perpendicular to gun direction
    var worldUp = {x: 0, y: 0, z: 1};

    // Right = gunDir cross worldUp
    var rightX = gunDirY * worldUp.z - gunDirZ * worldUp.y;
    var rightY = gunDirZ * worldUp.x - gunDirX * worldUp.z;
    var rightZ = gunDirX * worldUp.y - gunDirY * worldUp.x;
    var rightLen = Math.sqrt(rightX*rightX + rightY*rightY + rightZ*rightZ) || 1;
    rightX /= rightLen; rightY /= rightLen; rightZ /= rightLen;

    // Up = right cross gunDir
    var upX = rightY * gunDirZ - rightZ * gunDirY;
    var upY = rightZ * gunDirX - rightX * gunDirZ;
    var upZ = rightX * gunDirY - rightY * gunDirX;
    var upLen = Math.sqrt(upX*upX + upY*upY + upZ*upZ) || 1;
    upX /= upLen; upY /= upLen; upZ /= upLen;

    // Barrel offset in gun-relative space (scaled to world units)
    var bScale = gunModel.scale / 30;
    var fwd = gunModel.barrelX * bScale;
    var up = gunModel.barrelY * bScale;
    var right = gunModel.barrelZ * bScale;

    // Apply offsets in gun-direction space
    var barrelOffsetX = gunDirX * fwd + upX * up + rightX * right;
    var barrelOffsetY = gunDirY * fwd + upY * up + rightY * right;
    var barrelOffsetZ = gunDirZ * fwd + upZ * up + rightZ * right;

    return {
        x: gunWorldX + barrelOffsetX,
        y: gunWorldY + barrelOffsetY,
        z: gunWorldZ + barrelOffsetZ,
        // Also return the gun direction for convenience
        dirX: gunDirX,
        dirY: gunDirY,
        dirZ: gunDirZ
    };
}

// Load OBJ file
function loadGunModel() {
    fetch('3D_models/Gun _obj/Gun.obj')
        .then(response => response.text())
        .then(text => {
            var lines = text.split('\n');
            var vertices = [];
            var uvs = [];  // Texture coordinates
            var faces = [];

            lines.forEach(line => {
                var parts = line.trim().split(/\s+/);
                if (parts[0] === 'v') {
                    // Vertex: v x y z
                    vertices.push({
                        x: parseFloat(parts[1]),
                        y: parseFloat(parts[2]),
                        z: parseFloat(parts[3])
                    });
                } else if (parts[0] === 'vt') {
                    // Texture coordinate: vt u v
                    uvs.push({
                        u: parseFloat(parts[1]),
                        v: parseFloat(parts[2])
                    });
                } else if (parts[0] === 'f') {
                    // Face: f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3 ...
                    var faceVerts = [];
                    var faceUVs = [];
                    for (var i = 1; i < parts.length; i++) {
                        var indices = parts[i].split('/');
                        faceVerts.push(parseInt(indices[0]) - 1);  // OBJ is 1-indexed
                        if (indices[1]) {
                            faceUVs.push(parseInt(indices[1]) - 1);
                        }
                    }
                    // Triangulate quads (split into triangles)
                    if (faceVerts.length === 3) {
                        faces.push({ verts: faceVerts, uvs: faceUVs });
                    } else if (faceVerts.length === 4) {
                        faces.push({ verts: [faceVerts[0], faceVerts[1], faceVerts[2]], uvs: [faceUVs[0], faceUVs[1], faceUVs[2]] });
                        faces.push({ verts: [faceVerts[0], faceVerts[2], faceVerts[3]], uvs: [faceUVs[0], faceUVs[2], faceUVs[3]] });
                    }
                }
            });

            gunModel.vertices = vertices;
            gunModel.uvs = uvs;
            gunModel.faces = faces;
            gunModel.loaded = true;
            console.log('Gun model loaded:', vertices.length, 'vertices,', uvs.length, 'UVs,', faces.length, 'faces');
        })
        .catch(err => console.error('Failed to load gun model:', err));

    // Load gun texture
    gunModel.texture = new Image();
    gunModel.textureLoaded = false;
    gunModel.texture.onload = function() {
        // Create offscreen canvas for texture sampling
        gunModel.textureCanvas = document.createElement('canvas');
        gunModel.textureCanvas.width = gunModel.texture.width;
        gunModel.textureCanvas.height = gunModel.texture.height;
        var tctx = gunModel.textureCanvas.getContext('2d');
        tctx.drawImage(gunModel.texture, 0, 0);
        gunModel.textureData = tctx.getImageData(0, 0, gunModel.texture.width, gunModel.texture.height);
        gunModel.textureLoaded = true;
        console.log('Gun texture loaded:', gunModel.texture.width, 'x', gunModel.texture.height);
    };
    gunModel.texture.onerror = function() {
        console.error('Failed to load gun texture');
    };
    gunModel.texture.src = '3D_models/Gun _obj/Gun.png';
}

// Render gun viewmodel (first-person weapon overlay)
function RenderGunViewmodel(ctx) {
    var sw = screendata.canvas.width;
    var sh = screendata.canvas.height;

    // Screen position (from bottom-right)
    var centerX = sw - gunModel.offsetX;
    var centerY = sh - gunModel.offsetY;

    // Skip model rendering if not loaded, but still draw barrel marker
    if (!gunModel.loaded) {
        // Draw placeholder rectangle at gun position
        ctx.fillStyle = 'rgba(100,100,100,0.5)';
        ctx.fillRect(centerX - 50, centerY - 30, 100, 60);
        ctx.strokeStyle = 'white';
        ctx.strokeRect(centerX - 50, centerY - 30, 100, 60);
        ctx.fillStyle = 'yellow';
        ctx.font = '12px Arial';
        ctx.fillText('Gun loading...', centerX - 35, centerY + 5);
        // Still draw barrel marker
        var barrel = getBarrelScreenPos();
        ctx.beginPath();
        ctx.arc(barrel.x, barrel.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = 'cyan';
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
        return;
    }

    // Rotation angles
    var rotX = gunModel.rotationX * Math.PI / 180;
    var rotY = gunModel.rotationY * Math.PI / 180;
    var rotZ = gunModel.rotationZ * Math.PI / 180;

    var cosX = Math.cos(rotX), sinX = Math.sin(rotX);
    var cosY = Math.cos(rotY), sinY = Math.sin(rotY);
    var cosZ = Math.cos(rotZ), sinZ = Math.sin(rotZ);

    // Z Depth affects scale (negative = closer/bigger, positive = farther/smaller)
    var depthScale = 1 - gunModel.offsetZ / 200;
    var scale = gunModel.scale * depthScale;

    // Project all vertices to screen space
    var projected = gunModel.vertices.map(v => {
        var x = v.x, y = v.y, z = v.z;

        // Apply X rotation (pitch)
        var y1 = y * cosX - z * sinX;
        var z1 = y * sinX + z * cosX;

        // Apply Y rotation (yaw)
        var x2 = x * cosY + z1 * sinY;
        var z2 = -x * sinY + z1 * cosY;

        // Apply Z rotation (roll)
        var x3 = x2 * cosZ - y1 * sinZ;
        var y3 = x2 * sinZ + y1 * cosZ;

        // Simple orthographic projection for viewmodel
        // X goes right, Y goes up, Z is depth (for sorting)
        return {
            x: centerX + x3 * scale,
            y: centerY - y3 * scale,  // Y is inverted in screen coords
            z: z2 + gunModel.offsetZ / 100  // depth for sorting
        };
    });

    // Sort faces by average depth (painter's algorithm)
    var sortedFaces = gunModel.faces.map((faceData, i) => {
        var verts = faceData.verts;
        var avgZ = 0;
        verts.forEach(idx => avgZ += projected[idx].z);
        avgZ /= verts.length;
        return { faceData, avgZ, index: i };
    }).sort((a, b) => a.avgZ - b.avgZ);  // far faces first

    // Helper to sample texture color at UV coordinates
    function sampleTexture(u, v) {
        if (!gunModel.textureLoaded || !gunModel.textureData) {
            return { r: 128, g: 128, b: 128 };
        }
        var tw = gunModel.texture.width;
        var th = gunModel.texture.height;
        // Clamp and wrap UV coordinates
        u = u - Math.floor(u);
        v = 1 - (v - Math.floor(v));  // Flip V (OBJ uses bottom-left origin)
        var px = Math.floor(u * (tw - 1));
        var py = Math.floor(v * (th - 1));
        var idx = (py * tw + px) * 4;
        var data = gunModel.textureData.data;
        return {
            r: data[idx],
            g: data[idx + 1],
            b: data[idx + 2]
        };
    }

    // Draw faces
    sortedFaces.forEach(item => {
        var verts = item.faceData.verts;
        var uvIndices = item.faceData.uvs;
        var p0 = projected[verts[0]];
        var p1 = projected[verts[1]];
        var p2 = projected[verts[2]];

        // Backface culling using cross product (disabled for now to debug)
        var ax = p1.x - p0.x, ay = p1.y - p0.y;
        var bx = p2.x - p0.x, by = p2.y - p0.y;
        var cross = ax * by - ay * bx;
        // Skip culling - draw all faces for now
        // if (cross < 0) return;  // back-facing

        // Calculate shading based on face normal (simple lighting)
        var shade = 0.5 + 0.5 * Math.abs(cross) / (Math.sqrt(ax*ax + ay*ay) * Math.sqrt(bx*bx + by*by) + 0.001);
        shade = Math.min(1, Math.max(0.3, shade));

        // Sample texture color at face center UV
        var r = 128, g = 128, b = 128;
        if (uvIndices && uvIndices.length >= 3 && gunModel.uvs && gunModel.uvs.length > 0) {
            var uv0 = gunModel.uvs[uvIndices[0]] || {u:0.5, v:0.5};
            var uv1 = gunModel.uvs[uvIndices[1]] || {u:0.5, v:0.5};
            var uv2 = gunModel.uvs[uvIndices[2]] || {u:0.5, v:0.5};
            var centerU = (uv0.u + uv1.u + uv2.u) / 3;
            var centerV = (uv0.v + uv1.v + uv2.v) / 3;
            var texColor = sampleTexture(centerU, centerV);
            r = texColor.r;
            g = texColor.g;
            b = texColor.b;
        }

        // Apply shading to texture color
        r = Math.floor(r * shade);
        g = Math.floor(g * shade);
        b = Math.floor(b * shade);

        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.closePath();

        ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
        ctx.fill();

        // Optional: draw edges for definition
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 0.5;
        ctx.stroke();
    });

    // Draw barrel position marker (cyan dot)
    var barrel = getBarrelScreenPos();
    ctx.beginPath();
    ctx.arc(barrel.x, barrel.y, 4, 0, Math.PI * 2);
    ctx.fillStyle = 'cyan';
    ctx.fill();
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1;
    ctx.stroke();
}

// Render the 3D cube
function RenderCube() {
    // Precompute trig values once per frame
    cubeSinYaw = Math.sin(camera.angle);
    cubeCosYaw = Math.cos(camera.angle);

    var v = getCubeVertices();

    // Define the 6 faces with consistent CCW winding when viewed from outside
    // Each face uses slightly different shade of blue for visual distinction
    var faces = [
        {verts: [v[0], v[1], v[5], v[4]], color: 0xFF0000CC}, // Back face (y- side): 0->1->5->4
        {verts: [v[2], v[3], v[7], v[6]], color: 0xFF0000FF}, // Front face (y+ side): 2->3->7->6
        {verts: [v[3], v[0], v[4], v[7]], color: 0xFF0000AA}, // Left face (x- side): 3->0->4->7
        {verts: [v[1], v[2], v[6], v[5]], color: 0xFF0000DD}, // Right face (x+ side): 1->2->6->5
        {verts: [v[4], v[5], v[6], v[7]], color: 0xFF3333FF}, // Top face (z+ side): 4->5->6->7
        {verts: [v[3], v[2], v[1], v[0]], color: 0xFF000088}  // Bottom face (z- side): 3->2->1->0
    ];

    // Sort faces by average depth (painter's algorithm - draw far faces first)
    faces.forEach(function(face) {
        var totalDepth = 0;
        face.verts.forEach(function(vert) {
            var dx = vert.x - camera.x;
            var dy = vert.y - camera.y;
            totalDepth += -dx * cubeSinYaw - dy * cubeCosYaw;
        });
        face.avgDepth = totalDepth / 4;
    });

    faces.sort(function(a, b) { return b.avgDepth - a.avgDepth; });

    // Draw each face
    faces.forEach(function(face) {
        drawFilledQuad(face.verts[0], face.verts[1], face.verts[2], face.verts[3], face.color);
    });
}



function spawnRandomItems(type, texture, options = {}) {
    let step = options.step || 8;               // spacing (avoid too many)
    let chance = options.chance || 0.01;        // probability per tile
    let colorCheck = options.colorCheck || (()=>true); // which terrain allowed

    for (let y = 0; y < map.height; y += step) {
        for (let x = 0; x < map.width; x += step) {
            let idx = (y << map.shift) + x;
            let col = map.color[idx] & 0xFFFFFF;  // strip alpha

            if (colorCheck(col)) {
                if (Math.random() < chance) {
                    let wx = x;
                    let wy = y;
                    // Use raw terrain for static items so they sit on actual ground
                    let wz = getRawTerrainHeight(wx, wy);
                    items.push({
                        type: type,
                        x: wx, y: wy, z: wz,
                        dx: 0, dy: 0, dz: 0,
                        image: texture
                    });
                }
            }
        }
    }
}


// ===============================
var getRawTerrainHeight=(x,y)=>map.altitude[((Math.floor(y)&(map.width-1))<<map.shift)+(Math.floor(x)&(map.height-1))];
var getGroundHeight=(x,y)=>getRawTerrainHeight(x,y)+playerHeightOffset;
var MAX_SLOPE=2;
var isOnGround=()=>camera.height<=getGroundHeight(camera.x,camera.y)+0.1;
var canMoveTo=(nx,ny)=>{if(!isOnGround())return true;var curH=getGroundHeight(camera.x,camera.y),newH=getGroundHeight(nx,ny);if(newH<=curH)return true;var horizDist=Math.hypot(nx-camera.x,ny-camera.y);if(!horizDist)return true;return (newH-curH)/horizDist<=MAX_SLOPE};

function horizonToPitchRad(h){return h*90/500*Math.PI/180;}

// ===============================
// Camera + item updates
function UpdateCamera(){
    var current=Date.now(),deltaTime=(current-time)*0.03,
        isSprinting = input.sprint || input.gpSprint,
        baseSpeed=player.moveSpeed*(isSprinting?player.sprintMultiplier:1)*deltaTime,nx,ny,slopeMult;

    // Gamepad look (Right Stick)
    if(input.lookX !== 0 || input.lookY !== 0){
        camera.angle = (camera.angle - input.lookX * gamepad.lookSensitivity) % (2 * Math.PI);
        if(camera.angle < 0) camera.angle += 2 * Math.PI;
        camera.horizon = Math.max(-400, Math.min(600, camera.horizon - input.lookY * gamepad.lookSensitivity * 100));
    }

    // Keyboard Movement
    if(input.forward){nx=camera.x-Math.sin(camera.angle)*baseSpeed;ny=camera.y-Math.cos(camera.angle)*baseSpeed;slopeMult=canMoveTo(nx,ny);camera.x+=(nx-camera.x)*slopeMult;camera.y+=(ny-camera.y)*slopeMult;}
    if(input.backward){nx=camera.x+Math.sin(camera.angle)*baseSpeed;ny=camera.y+Math.cos(camera.angle)*baseSpeed;slopeMult=canMoveTo(nx,ny);camera.x+=(nx-camera.x)*slopeMult;camera.y+=(ny-camera.y)*slopeMult;}
    if(input.left){nx=camera.x-Math.cos(camera.angle)*baseSpeed;ny=camera.y+Math.sin(camera.angle)*baseSpeed;slopeMult=canMoveTo(nx,ny);camera.x+=(nx-camera.x)*slopeMult;camera.y+=(ny-camera.y)*slopeMult;}
    if(input.right){nx=camera.x+Math.cos(camera.angle)*baseSpeed;ny=camera.y-Math.sin(camera.angle)*baseSpeed;slopeMult=canMoveTo(nx,ny);camera.x+=(nx-camera.x)*slopeMult;camera.y+=(ny-camera.y)*slopeMult;}

    // Gamepad Movement (Left Stick) - analog for smooth control
    if(input.moveX !== 0 || input.moveY !== 0){
        var fx = -Math.sin(camera.angle), fy = -Math.cos(camera.angle); // forward
        var rx = Math.cos(camera.angle), ry = -Math.sin(camera.angle);  // right
        var moveSpeed = baseSpeed * Math.min(1, Math.hypot(input.moveX, input.moveY));

        nx = camera.x + (fx * -input.moveY + rx * input.moveX) * moveSpeed;
        ny = camera.y + (fy * -input.moveY + ry * input.moveX) * moveSpeed;
        slopeMult = canMoveTo(nx, ny);
        camera.x += (nx - camera.x) * slopeMult;
        camera.y += (ny - camera.y) * slopeMult;
    }

    camera.velocityY-=0.5*deltaTime;camera.height+=camera.velocityY*deltaTime;

    // Ground clamping FIRST - ensures consistent state for jump check
    var groundHeight=getGroundHeight(camera.x,camera.y);
    var wasInAir = camera.height > groundHeight + 1; // track if falling
    if(camera.height < groundHeight){
        camera.height = groundHeight;
        camera.velocityY = 0;
    }

    // Crouch handling
    var isCrouching = input.crouch || input.gpCrouch;
    if(isCrouching){if(!player.isCrouching){player.isCrouching=true;}}
    else if(player.isCrouching){player.isCrouching=false;}

    // Charged jump system - hold to charge, release to jump
    var jumpHeld = input.jump || input.gpJumpHeld;
    var jumpBar = document.getElementById('jumpbar');
    var jumpCharge = document.getElementById('jumpcharge');
    // More forgiving ground check: within 2 units of ground and not moving up fast
    var onGround = (camera.height <= groundHeight + 2) && (camera.velocityY <= 0.5);

    if(jumpHeld){
        // Button is held
        if(onGround && !player.isChargingJump){
            // Just started pressing while on ground - begin charging
            player.isChargingJump = true;
            player.jumpChargeTime = 0;
        }

        if(player.isChargingJump){
            // Continue charging (don't require ground check each frame)
            player.jumpChargeTime = Math.min(player.jumpChargeTime + (current - time), player.jumpMaxChargeTime);

            // Show and update charge bar
            if(jumpBar) jumpBar.style.display = 'block';
            if(jumpCharge){
                var chargePercent = (player.jumpChargeTime / player.jumpMaxChargeTime) * 100;
                jumpCharge.style.width = chargePercent + '%';
            }
        }
    } else {
        // Button released
        if(player.isChargingJump){
            // Was charging - JUMP!
            var chargeRatio = player.jumpChargeTime / player.jumpMaxChargeTime;
            var jumpStrength = player.jumpMinStrength + (player.jumpMaxStrength - player.jumpMinStrength) * chargeRatio;
            camera.velocityY = jumpStrength;
        }

        // Reset charge state
        player.isChargingJump = false;
        player.jumpChargeTime = 0;
        if(jumpBar) jumpBar.style.display = 'none';
        if(jumpCharge) jumpCharge.style.width = '0%';
    }

    // Weapon swap (Q key or Y button)
    var wantSwap = input.swapWeapon || input.gpSwapWeapon;
    if(wantSwap && !player.wasSwapping){
        currentWeaponIndex = (currentWeaponIndex + 1) % 2;
    }
    player.wasSwapping = wantSwap;
    input.swapWeapon = false;  // Reset edge-triggered input
    input.gpSwapWeapon = false;

    // Get current weapon info
    var currentSlot = playerWeapons[currentWeaponIndex];
    var currentWeapon = weapons[currentSlot.type];

    // Check for nearby ground weapons (within 15 degrees of view and close enough)
    nearbyWeapon = null;
    var fx = -Math.sin(camera.angle), fy = -Math.cos(camera.angle);
    groundWeapons.forEach(function(gw) {
        var dx = gw.x - camera.x;
        var dy = gw.y - camera.y;
        var dist = Math.hypot(dx, dy);
        if(dist < 50) {  // Within pickup range
            // Check if facing it (within 15 degrees)
            var dot = (dx * fx + dy * fy) / dist;
            if(dot > Math.cos(15 * Math.PI / 180)) {  // cos(15Â°) â 0.966
                nearbyWeapon = gw;
            }
        }
    });

    // Pickup weapon (E key or X button when near weapon)
    var wantPickup = input.pickupWeapon || input.gpPickupWeapon;
    if(wantPickup && nearbyWeapon && !player.wasPickingUp){
        // Swap current weapon with ground weapon
        var oldType = currentSlot.type;
        var oldAmmo = currentSlot.ammo;
        currentSlot.type = nearbyWeapon.type;
        currentSlot.ammo = weapons[nearbyWeapon.type].maxMagazine;
        currentSlot.isReloading = false;
        // Put old weapon on ground
        nearbyWeapon.type = oldType;
        nearbyWeapon.ammo = oldAmmo;
    }
    player.wasPickingUp = wantPickup;

    // Shooting - Hip fire or Iron sights (ADS)
    var isShooting = input.shoot || input.gpShoot;
    var isAiming = input.aimToggled;

    // ADS handling - Camera 1 (main) stays normal, scope uses Camera 2
    var fx = -Math.sin(camera.angle);
    var fy = -Math.cos(camera.angle);

    // Update scope camera state (Camera 2 for PiP) - using modular scope system
    if (activeScope) {
        activeScope.updateCamera(isAiming, currentWeapon.useScope);
    }

    // Main camera (Camera 1) - normal ADS behavior, unchanged for scoped weapons
    var adsForwardDistance = currentWeapon.useScope ? 0 : (currentWeapon.adsZoom - 1) * 30;
    var targetOffset = isAiming && !currentWeapon.useScope ? adsForwardDistance : 0;
    camera.adsOffset += (targetOffset - camera.adsOffset) * 0.15;

    // Keep main camera focal length constant
    camera.focalLength = camera.baseFocalLength;

    // Apply offset along look direction for main camera
    camera.baseX = camera.x - fx * camera.adsOffset;
    camera.baseY = camera.y - fy * camera.adsOffset;
    camera.x = camera.baseX + fx * camera.adsOffset;
    camera.y = camera.baseY + fy * camera.adsOffset;

    // Interpolate gun position between hip fire and ADS
    var targetLerp = isAiming ? 1 : 0;
    gunModel.adsLerp += (targetLerp - gunModel.adsLerp) * gunModel.adsLerpSpeed;

    // Lerp helper function
    function lerp(a, b, t) { return a + (b - a) * t; }

    // Update current gun position/rotation based on interpolation
    gunModel.offsetX = lerp(gunModel.hipOffsetX, gunModel.adsOffsetX, gunModel.adsLerp);
    gunModel.offsetY = lerp(gunModel.hipOffsetY, gunModel.adsOffsetY, gunModel.adsLerp);
    gunModel.offsetZ = lerp(gunModel.hipOffsetZ, gunModel.adsOffsetZ, gunModel.adsLerp);
    gunModel.scale = lerp(gunModel.hipScale, gunModel.adsScale, gunModel.adsLerp);
    gunModel.rotationX = lerp(gunModel.hipRotationX, gunModel.adsRotationX, gunModel.adsLerp);
    gunModel.rotationY = lerp(gunModel.hipRotationY, gunModel.adsRotationY, gunModel.adsLerp);
    gunModel.rotationZ = lerp(gunModel.hipRotationZ, gunModel.adsRotationZ, gunModel.adsLerp);

    // Update current barrel settings based on interpolation
    gunModel.barrelX = lerp(gunModel.hipBarrelX, gunModel.adsBarrelX, gunModel.adsLerp);
    gunModel.barrelY = lerp(gunModel.hipBarrelY, gunModel.adsBarrelY, gunModel.adsLerp);
    gunModel.barrelZ = lerp(gunModel.hipBarrelZ, gunModel.adsBarrelZ, gunModel.adsLerp);
    gunModel.barrelYaw = lerp(gunModel.hipBarrelYaw, gunModel.adsBarrelYaw, gunModel.adsLerp);

    // Update current world offset based on interpolation
    gunModel.worldForward = lerp(gunModel.hipWorldForward, gunModel.adsWorldForward, gunModel.adsLerp);
    gunModel.worldRight = lerp(gunModel.hipWorldRight, gunModel.adsWorldRight, gunModel.adsLerp);
    gunModel.worldDown = lerp(gunModel.hipWorldDown, gunModel.adsWorldDown, gunModel.adsLerp);

    // Update pivot mode based on ADS state
    gunModel.pivotMode = isAiming ? 'barrel' : 'grip';

    // Update crosshair style based on ADS and current weapon
    var crosshair = document.getElementById('crosshair');
    if(crosshair){
        // Hide crosshair when using scope (scope has its own reticle)
        if(isAiming && currentWeapon.useScope){
            crosshair.style.display = 'none';
        } else if(isAiming){
            crosshair.style.display = 'block';
            crosshair.style.borderColor = currentWeapon.color;
            crosshair.style.width = '6px';
            crosshair.style.height = '6px';
            crosshair.style.margin = '-3px 0 0 -3px';
        } else {
            crosshair.style.display = 'block';
            crosshair.style.borderColor = 'white';
            crosshair.style.width = '10px';
            crosshair.style.height = '10px';
            crosshair.style.margin = '-5px 0 0 -5px';
        }
    }

    // Check fire mode - semi-auto requires trigger release between shots
    var canShoot = true;
    if(currentWeapon.fireMode === "semi" && player.wasShooting){
        canShoot = false;
    }
    player.wasShooting = isShooting;

    if(isShooting && canShoot && !currentSlot.isReloading && currentSlot.ammo > 0 && current - currentSlot.lastShot > currentWeapon.fireRate){
        var bulletSpeed = currentWeapon.bulletSpeed;

        // Camera direction vectors (horizontal)
        var fx = -Math.sin(camera.angle), fy = -Math.cos(camera.angle);
        var rx = Math.cos(camera.angle), ry = -Math.sin(camera.angle);

        // Get bullet direction based on ADS mode
        var aimDirX, aimDirY, aimDirZ;
        if (gunModel.pivotMode === 'barrel') {
            // ADS mode: bullet goes toward SCREEN CENTER (where crosshair is)
            // Calculate pitch that corresponds to screen center, not horizon-based pitch
            var screenCenterY = screendata.canvas.height / 2;
            var screenCenterPitch = Math.atan((camera.horizon - screenCenterY) / camera.focalLength);
            var cosPitch = Math.cos(screenCenterPitch);
            var sinPitch = Math.sin(screenCenterPitch);
            aimDirX = fx * cosPitch;
            aimDirY = fy * cosPitch;
            aimDirZ = sinPitch;
        } else {
            // Hip fire mode: use gun's own rotation
            var gunDir = getGunWorldDirection();
            aimDirX = gunDir.x;
            aimDirY = gunDir.y;
            aimDirZ = gunDir.z;
        }

        // Apply spread based on hip fire vs ADS (from WeaponConfig)
        var weaponSpread = WeaponConfig.getWeaponSpread(currentSlot.type);
        var spread = isAiming ? weaponSpread.adsSpread : weaponSpread.hipSpread;
        var spreadX = (Math.random() - 0.5) * spread;
        var spreadY = (Math.random() - 0.5) * spread;

        // Add spread to aim direction
        var dirx = aimDirX + rx * spreadX;
        var diry = aimDirY + ry * spreadX;
        var dirz = aimDirZ + spreadY;

        var mag = Math.hypot(dirx, diry, dirz) || 1;
        dirx = (dirx / mag) * bulletSpeed;
        diry = (diry / mag) * bulletSpeed;
        dirz = (dirz / mag) * bulletSpeed;

        // Spawn bullet from gun barrel position in world space
        // getBarrelWorldPos() already calculates direction based on pivot mode
        var barrelPos = getBarrelWorldPos();
        var spawnX = barrelPos.x + barrelPos.dirX * gunModel.barrelDistance;
        var spawnY = barrelPos.y + barrelPos.dirY * gunModel.barrelDistance;
        var spawnZ = barrelPos.z + barrelPos.dirZ * gunModel.barrelDistance;

        lastBulletDestroyedPos = null;
        lastBulletDestroyedReason = null;

        // Normalize direction for raycast
        var rayDirX = dirx / bulletSpeed;
        var rayDirY = diry / bulletSpeed;
        var rayDirZ = dirz / bulletSpeed;

        // Try hitscan first (for targets within hitscan range)
        // Skip hitscan for weapons with ccdOnly flag (like sniper rifles)
        var hitscanHitPos = null;  // Will store hit position if hitscan succeeds
        if (testTarget.enabled && hitscanDistance > 0 && !currentWeapon.ccdOnly) {
            // Ray-sphere intersection test
            // Ray origin: spawnX, spawnY, spawnZ
            // Ray direction: rayDirX, rayDirY, rayDirZ (normalized)
            // Sphere center: testTarget.x, testTarget.y, testTarget.z
            // Sphere radius: testTarget.radius
            var ocX = spawnX - testTarget.x;
            var ocY = spawnY - testTarget.y;
            var ocZ = spawnZ - testTarget.z;

            var a = rayDirX*rayDirX + rayDirY*rayDirY + rayDirZ*rayDirZ;
            var b = 2 * (ocX*rayDirX + ocY*rayDirY + ocZ*rayDirZ);
            var c = ocX*ocX + ocY*ocY + ocZ*ocZ - testTarget.radius*testTarget.radius;
            var discriminant = b*b - 4*a*c;

            if (discriminant >= 0) {
                // Ray intersects sphere - find closest intersection
                var t = (-b - Math.sqrt(discriminant)) / (2*a);
                if (t < 0) t = (-b + Math.sqrt(discriminant)) / (2*a);  // Use far intersection if behind

                if (t >= 0 && t <= hitscanDistance) {
                    // Hit within hitscan range! Record hit but still spawn bullet
                    testTarget.hits++;
                    var hitX = spawnX + rayDirX * t;
                    var hitY = spawnY + rayDirY * t;
                    var hitZ = spawnZ + rayDirZ * t;
                    hitscanHitPos = {x: hitX, y: hitY, z: hitZ, dist: t};
                    testTarget.bulletHitPos = {
                        x: hitX - testTarget.x,
                        y: hitY - testTarget.y,
                        z: hitZ - testTarget.z,
                        dist: Math.sqrt((hitX-testTarget.x)**2 + (hitY-testTarget.y)**2 + (hitZ-testTarget.z)**2)
                    };
                }
            }
        }

        // Always spawn a bullet (for visual), but mark if it's a hitscan bullet
        var bullet = {
            type: "bullet",
            x: spawnX, y: spawnY, z: spawnZ,
            prevX: spawnX, prevY: spawnY, prevZ: spawnZ,  // For CCD
            dx: dirx, dy: diry, dz: dirz,
            distance: 0,
            image: textures.bullet,
            damage: currentWeapon.damage,
            hitscanHit: hitscanHitPos,  // If set, bullet stops here (hit already registered)
            stopDistance: hitscanHitPos ? hitscanHitPos.dist : null
        };
        lastBullet = bullet;
        items.push(bullet);

        currentSlot.ammo--;
        currentSlot.lastShot = current;
    }

    // Reload current weapon
    var isReloading = input.reload || input.gpReload;
    if(isReloading && !currentSlot.isReloading && currentSlot.ammo < currentWeapon.maxMagazine){
        currentSlot.isReloading = true;
        setTimeout(function(){
            currentSlot.ammo = currentWeapon.maxMagazine;
            currentSlot.isReloading = false;
        }, currentWeapon.reloadTime);
    }

    // Update moving items (bullets only) - with CCD collision detection
    items = items.filter(it=>{
        if(it.type==="bullet"){
            // Store previous position for CCD
            it.prevX = it.x;
            it.prevY = it.y;
            it.prevZ = it.z;

            // Move bullet
            it.x+=it.dx*deltaTime;it.y+=it.dy*deltaTime;it.z+=it.dz*deltaTime;it.distance+=Math.hypot(it.dx,it.dy,it.dz)*deltaTime;

            // Check if this is a hitscan bullet that should stop at its hit point
            if (it.hitscanHit && it.distance >= it.stopDistance) {
                // Bullet reached hitscan hit point - stop it here
                if(it===lastBullet){
                    lastBullet=null;
                    lastBulletDestroyedPos={x:it.hitscanHit.x, y:it.hitscanHit.y, z:it.hitscanHit.z};
                    lastBulletDestroyedReason="Hitscan Hit!";
                }
                return false;
            }

            // CCD: Check for test target hit using line segment intersection (skip if hitscan already hit)
            if (testTarget.enabled && !it.hitscanHit) {
                // Line segment from prevPos to currentPos
                var segDirX = it.x - it.prevX;
                var segDirY = it.y - it.prevY;
                var segDirZ = it.z - it.prevZ;
                var segLen = Math.sqrt(segDirX*segDirX + segDirY*segDirY + segDirZ*segDirZ);

                if (segLen > 0) {
                    // Normalize segment direction
                    var rayDirX = segDirX / segLen;
                    var rayDirY = segDirY / segLen;
                    var rayDirZ = segDirZ / segLen;

                    // Ray-sphere intersection (ray starts at prevPos)
                    var ocX = it.prevX - testTarget.x;
                    var ocY = it.prevY - testTarget.y;
                    var ocZ = it.prevZ - testTarget.z;

                    var a = rayDirX*rayDirX + rayDirY*rayDirY + rayDirZ*rayDirZ;
                    var b = 2 * (ocX*rayDirX + ocY*rayDirY + ocZ*rayDirZ);
                    var c = ocX*ocX + ocY*ocY + ocZ*ocZ - testTarget.radius*testTarget.radius;
                    var discriminant = b*b - 4*a*c;

                    if (discriminant >= 0) {
                        var t = (-b - Math.sqrt(discriminant)) / (2*a);
                        if (t < 0) t = (-b + Math.sqrt(discriminant)) / (2*a);

                        // Check if intersection is within segment length (0 to segLen)
                        if (t >= 0 && t <= segLen) {
                            // CCD Hit!
                            testTarget.hits++;
                            var hitX = it.prevX + rayDirX * t;
                            var hitY = it.prevY + rayDirY * t;
                            var hitZ = it.prevZ + rayDirZ * t;
                            testTarget.bulletHitPos = {
                                x: hitX - testTarget.x,
                                y: hitY - testTarget.y,
                                z: hitZ - testTarget.z,
                                dist: Math.sqrt((hitX-testTarget.x)**2 + (hitY-testTarget.y)**2 + (hitZ-testTarget.z)**2)
                            };
                            if(it===lastBullet){lastBullet=null;lastBulletDestroyedPos={x:hitX,y:hitY,z:hitZ};lastBulletDestroyedReason="CCD Hit!";}
                            return false;
                        }
                    }

                    // Miss detection: if bullet passed target plane
                    var prevDist = Math.sqrt((it.prevX-testTarget.x)**2 + (it.prevY-testTarget.y)**2);
                    var currDist = Math.sqrt((it.x-testTarget.x)**2 + (it.y-testTarget.y)**2);
                    if (it.prevDistToTarget && it.prevDistToTarget < currDist && it.prevDistToTarget < testTarget.radius * 3) {
                        testTarget.misses++;
                    }
                    it.prevDistToTarget = currDist;
                }
            }

            // Terrain collision
            var terrainHeight=getRawTerrainHeight(it.x,it.y);
            if(it.z<=terrainHeight){if(it===lastBullet){lastBullet=null;lastBulletDestroyedPos={x:it.x,y:it.y,z:it.z};lastBulletDestroyedReason="Terrain Collision";}return false;}

            // Max distance check (use ccdMaxDistance)
            if(it.distance>=ccdMaxDistance){if(it===lastBullet){lastBullet=null;lastBulletDestroyedPos={x:it.x,y:it.y,z:it.z};lastBulletDestroyedReason="Max Range";}return false;}
        }
        return true;
    });

    // HUD updates
    document.getElementById('health').style.width=player.health+'%';
    var wepSlot = playerWeapons[currentWeaponIndex];
    var wepDef = weapons[wepSlot.type];
    document.getElementById('debug-bulletcount').innerText=`${wepDef.name}: ${wepSlot.ammo}/${wepDef.maxMagazine}${wepSlot.isReloading ? ' [RELOADING]' : ''}`;
    document.getElementById('debug-playerposition').innerText=`(${camera.x.toFixed(1)}, ${camera.y.toFixed(1)}, ${camera.height.toFixed(1)})`;
    document.getElementById('debug-playerrotation').innerText=`${(camera.angle*180/Math.PI).toFixed(1)}Â°, ${(camera.horizon*90/500).toFixed(1)}Â°`;
    document.getElementById('debug-lastbulletpos').innerText=lastBullet?`(${lastBullet.x.toFixed(1)}, ${lastBullet.y.toFixed(1)}, ${lastBullet.z.toFixed(1)})`:`None`;
    document.getElementById('debug-lastbulletscreen').innerText=lastBulletScreen?`(${lastBulletScreen.x.toFixed(0)}, ${lastBulletScreen.y.toFixed(0)}) z:${lastBulletScreen.z.toFixed(1)}`:`None`;
    document.getElementById('debug-lastbulletdestroyedpos').innerText=lastBulletDestroyedPos?`(${lastBulletDestroyedPos.x.toFixed(1)}, ${lastBulletDestroyedPos.y.toFixed(1)}, ${lastBulletDestroyedPos.z.toFixed(1)})`:`None`;
    document.getElementById('debug-lastbulletdestroyedreason').innerText=lastBulletDestroyedReason?`${lastBulletDestroyedReason}`:`None`;

    time=current;
}

// ===============================
function DrawBackground(){
    var buf32=screendata.buf32,len=buf32.length,bg=screendata.backgroundcolor;
    screendata.depthBuffer.fill(Infinity);
    for(var i=0;i<len;i++)buf32[i]=bg;
}
function Flip(){screendata.imagedata.data.set(screendata.buf8);screendata.context.putImageData(screendata.imagedata,0,0);}

// ===============================
// Render terrain + items
function Render(){
    var sw=screendata.canvas.width,sh=screendata.canvas.height,
        sinang=Math.sin(camera.angle),cosang=Math.cos(camera.angle),
        deltaz=1,depth=screendata.depthBuffer;

    hiddeny.fill(sh);
    for(var z=1;z<camera.distance;z+=deltaz){
        var plx=-cosang*z-sinang*z,ply=sinang*z-cosang*z,prx=cosang*z-sinang*z,pry=-sinang*z-cosang*z,dx=(prx-plx)/sw,dy=(pry-ply)/sw;
        plx+=camera.x;ply+=camera.y;var invz = camera.focalLength / z;
        for(var i=0;i<sw;i++){
            var mapoffset=((Math.floor(ply)&(map.width-1))<<map.shift)+(Math.floor(plx)&(map.height-1));
            var heightonscreen=(camera.height-map.altitude[mapoffset])*invz+camera.horizon;
            if(heightonscreen<hiddeny[i]){
                for(var k=heightonscreen|0;k<hiddeny[i];k++){
                    var idx=k*sw+i;
                    if(z<depth[idx]){screendata.buf32[idx]=map.color[mapoffset];depth[idx]=z;}
                }
                hiddeny[i]=heightonscreen;
            }
            plx+=dx;ply+=dy;
        }
        if(z>1000)deltaz+=0.02;else deltaz+=0.005;
    }

    // Project & draw items
    var pitch=horizonToPitchRad(camera.horizon-pitchOffset),
        sinYaw=Math.sin(camera.angle),cosYaw=Math.cos(camera.angle),
        sinPitch=Math.sin(pitch),cosPitch=Math.cos(pitch),
        fx=-sinYaw*cosPitch,fy=-cosYaw*cosPitch,fz=sinPitch,
        rx=Math.cos(camera.angle),ry=-Math.sin(camera.angle),focal=camera.focalLength;


    items.forEach(it=>{
        var dx=it.x-camera.x,dy=it.y-camera.y,dz=it.z-camera.height,
            forward=dx*fx+dy*fy+dz*fz;
        if(forward<=0.1||forward>camera.distance)return;
        var right=dx*rx+dy*ry,invz=focal/forward,
            screenX=right*invz+sw/2,screenY=(camera.height-it.z)*invz+camera.horizon;
        if(screenX<-50||screenX>sw+50||screenY<-50||screenY>sh+50)return;

        var scale=10*invz;
        if(it.image.complete){
            screendata.context.drawImage(it.image, screenX-scale/2, screenY-scale/2, scale, scale);
        }
    });
}


// Cache for image pixel data at fixed base resolution
var imageDataCache = {};
var BASE_SIZE = 64; // single cached size per image

function getImagePixelData(img) {
    var key = img.src;
    if (imageDataCache[key]) return imageDataCache[key];

    var canvas = document.createElement('canvas');
    canvas.width = BASE_SIZE;
    canvas.height = BASE_SIZE;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, BASE_SIZE, BASE_SIZE);
    var data = ctx.getImageData(0, 0, BASE_SIZE, BASE_SIZE);
    imageDataCache[key] = data;
    return data;
}

function RenderItems(){
    var sw = screendata.canvas.width,
        sh = screendata.canvas.height,
        depth = screendata.depthBuffer,
        buf32 = screendata.buf32,
        sinYaw = Math.sin(camera.angle),
        cosYaw = Math.cos(camera.angle),
        rx = cosYaw, ry = -sinYaw,
        focal = camera.focalLength;

    // Project items using ground-plane distance (consistent with terrain rendering)
    let projected = items.map(it => {
        var dx = it.x - camera.x,
            dy = it.y - camera.y;
        var groundForward = -dx*sinYaw - dy*cosYaw;
        return {it, dx, dy, groundForward};
    });

    // Filter valid + sort back-to-front (far items first)
    projected = projected
        .filter(obj => obj.groundForward > 0.1 && obj.groundForward < camera.distance)
        .sort((a,b) => b.groundForward - a.groundForward);

    // Draw each item pixel-by-pixel with depth testing
    projected.forEach(obj => {
        let it = obj.it;
        let dx = obj.dx, dy = obj.dy;
        let groundForward = obj.groundForward;

        var right = dx*rx + dy*ry;
        var screenX = right * (sw / 2) / groundForward + sw/2;
        var screenY = (camera.height - it.z) * focal / groundForward + camera.horizon;

        var scale = 12 * focal / groundForward;
        var scaleX = scale;
        var scaleY = scale;
        if (it.type === "tree") {
            scaleX *= 6;   // wider trees
            scaleY *= 12;  // much taller trees (stretched)
        }
        if (it.type === "bullet") {
            scaleX *= bulletSize;
            scaleY *= bulletSize;
            // Track screen position for debugging
            lastBulletScreen = {x: screenX, y: screenY, z: it.z, camH: camera.height, gf: groundForward};
        }

        // Quick bounds check
        if (screenX < -scaleX || screenX >= sw + scaleX || screenY < -scaleY || screenY >= sh + scaleY) return;
        if (!it.image || !it.image.complete) return;

        // Get cached image pixel data (fixed size)
        var imgData = getImagePixelData(it.image);
        var srcSize = imgData.width; // BASE_SIZE
        var pixels = imgData.data;

        // Destination size and position using actual scale
        var destW = Math.max(1, Math.ceil(scaleX));
        var destH = Math.max(1, Math.ceil(scaleY));
        var destX = Math.floor(screenX - destW/2);
        var destY = Math.floor(screenY - destH);

        // Draw each destination pixel, sampling from source
        for (var py = 0; py < destH; py++) {
            var sy = destY + py;
            if (sy < 0 || sy >= sh) continue;

            // Map destination Y to source Y
            var srcY = Math.floor(py * srcSize / destH);

            for (var px = 0; px < destW; px++) {
                var sx = destX + px;
                if (sx < 0 || sx >= sw) continue;

                var bufIdx = sy * sw + sx;

                // Depth test - only draw if in front of terrain
                if (groundForward >= depth[bufIdx]) continue;

                // Map destination X to source X
                var srcX = Math.floor(px * srcSize / destW);
                var srcIdx = (srcY * srcSize + srcX) * 4;

                var a = pixels[srcIdx + 3];
                if (a < 128) continue; // skip transparent pixels

                var r = pixels[srcIdx];
                var g = pixels[srcIdx + 1];
                var b = pixels[srcIdx + 2];

                // Write to buffer (ABGR format for Uint32Array on little-endian)
                buf32[bufIdx] = 0xFF000000 | (b << 16) | (g << 8) | r;
            }
        }
    });
}

// Render the test target as a circle in 3D space
function RenderTestTarget() {
    if (!testTarget.enabled) return;

    var ctx = screendata.context;
    var sw = screendata.canvas.width;
    var sh = screendata.canvas.height;
    var sinYaw = Math.sin(camera.angle);
    var cosYaw = Math.cos(camera.angle);
    var focal = camera.focalLength;

    // Calculate position relative to camera
    var dx = testTarget.x - camera.x;
    var dy = testTarget.y - camera.y;
    var dz = testTarget.z - camera.height;

    // Ground-plane distance (forward from camera)
    var groundForward = -dx * sinYaw - dy * cosYaw;

    // Don't render if behind camera or too far
    if (groundForward < 1 || groundForward > camera.distance) return;

    // Right offset
    var rx = cosYaw, ry = -sinYaw;
    var right = dx * rx + dy * ry;

    // Screen position
    var screenX = right * (sw / 2) / groundForward + sw / 2;
    var screenY = -dz * focal / groundForward + camera.horizon;

    // Scale radius based on distance
    var screenRadius = testTarget.radius * focal / groundForward;

    // Don't render if off screen
    if (screenX < -screenRadius || screenX > sw + screenRadius) return;
    if (screenY < -screenRadius || screenY > sh + screenRadius) return;

    // Draw outer ring (white)
    ctx.beginPath();
    ctx.arc(screenX, screenY, screenRadius, 0, Math.PI * 2);
    ctx.strokeStyle = testTarget.ringColor;
    ctx.lineWidth = 3;
    ctx.stroke();

    // Draw inner circle (red)
    ctx.beginPath();
    ctx.arc(screenX, screenY, screenRadius * 0.3, 0, Math.PI * 2);
    ctx.fillStyle = testTarget.color;
    ctx.fill();

    // Draw crosshair on target
    ctx.beginPath();
    ctx.moveTo(screenX - screenRadius, screenY);
    ctx.lineTo(screenX + screenRadius, screenY);
    ctx.moveTo(screenX, screenY - screenRadius);
    ctx.lineTo(screenX, screenY + screenRadius);
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Draw center dot
    ctx.beginPath();
    ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#ffff00';
    ctx.fill();
}

// Draw gun mechanics debug info overlay
function DrawGunDebugInfo() {
    if (!showGMD || !testTarget.enabled) return;

    var ctx = screendata.context;
    var x = 10;
    var y = 150;
    var lineHeight = 14;

    ctx.font = '12px monospace';
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(x - 5, y - 15, 300, 300);

    ctx.fillStyle = '#00ff00';
    ctx.fillText('=== GUN MECHANICS DEBUG ===', x, y);
    y += lineHeight + 5;

    // Camera info
    ctx.fillStyle = '#ffffff';
    var cameraPitch = horizonToPitchRad(camera.horizon - pitchOffset) * 180 / Math.PI;
    var screenCenterPitch = Math.atan((camera.horizon - screendata.canvas.height/2) / camera.focalLength) * 180 / Math.PI;
    var cameraAngleDeg = (camera.angle * 180 / Math.PI) % 360;
    ctx.fillText('Camera Angle: ' + cameraAngleDeg.toFixed(1) + 'Â°', x, y); y += lineHeight;
    ctx.fillText('Horizon Pitch: ' + cameraPitch.toFixed(1) + 'Â° | Crosshair: ' + screenCenterPitch.toFixed(1) + 'Â°', x, y); y += lineHeight;
    ctx.fillText('Camera Height: ' + camera.height.toFixed(1), x, y); y += lineHeight;
    y += 5;

    // Target info
    ctx.fillStyle = '#ffff00';
    ctx.fillText('--- Target ---', x, y); y += lineHeight;
    ctx.fillStyle = '#ffffff';
    ctx.fillText('Distance: ' + testTarget.playerDistance.toFixed(1) + ' units', x, y); y += lineHeight;
    ctx.fillText('Horiz Angle to Target: ' + testTarget.angleToTarget.toFixed(1) + 'Â°', x, y); y += lineHeight;
    ctx.fillText('Pitch to Target: ' + testTarget.pitchToTarget.toFixed(1) + 'Â°', x, y); y += lineHeight;
    ctx.fillText('Aim Error: ' + testTarget.aimError.toFixed(1) + 'Â°', x, y); y += lineHeight;
    y += 5;

    // Gun info
    ctx.fillStyle = '#00ffff';
    ctx.fillText('--- Gun State ---', x, y); y += lineHeight;
    ctx.fillStyle = '#ffffff';
    ctx.fillText('Pivot Mode: ' + gunModel.pivotMode, x, y); y += lineHeight;
    ctx.fillText('ADS Lerp: ' + gunModel.adsLerp.toFixed(2), x, y); y += lineHeight;
    ctx.fillText('Rotation X/Y/Z: ' + gunModel.rotationX.toFixed(0) + '/' +
                 gunModel.rotationY.toFixed(0) + '/' + gunModel.rotationZ.toFixed(0), x, y); y += lineHeight;
    y += 5;

    // Barrel info
    var barrelPos = getBarrelWorldPos();
    ctx.fillStyle = '#ff00ff';
    ctx.fillText('--- Barrel/Spawn ---', x, y); y += lineHeight;
    ctx.fillStyle = '#ffffff';
    ctx.fillText('Barrel World Pos: ' + barrelPos.x.toFixed(1) + ', ' +
                 barrelPos.y.toFixed(1) + ', ' + barrelPos.z.toFixed(1), x, y); y += lineHeight;
    ctx.fillText('Barrel Dir: ' + barrelPos.dirX.toFixed(2) + ', ' +
                 barrelPos.dirY.toFixed(2) + ', ' + barrelPos.dirZ.toFixed(2), x, y); y += lineHeight;

    // Hit tracking
    y += 5;
    ctx.fillStyle = '#00ff00';
    ctx.fillText('Hits: ' + testTarget.hits + '  Misses: ' + testTarget.misses, x, y); y += lineHeight;

    // Last hit position (offset from center)
    if (testTarget.bulletHitPos) {
        ctx.fillStyle = '#ffff00';
        ctx.fillText('Last Hit Offset: ' + testTarget.bulletHitPos.x.toFixed(2) + ', ' +
                     testTarget.bulletHitPos.y.toFixed(2) + ', ' + testTarget.bulletHitPos.z.toFixed(2), x, y); y += lineHeight;
        ctx.fillText('Hit Dist from Center: ' + testTarget.bulletHitPos.dist.toFixed(2), x, y);
    }

    // Controls hint
    y += lineHeight + 5;
    ctx.fillStyle = '#888888';
    ctx.fillText('T = reposition target | G = toggle target', x, y);
}

// Render sniper scope - uses modular scope system
// Scope modes: ScopeForwardPosition (camera ahead) or ScopeFocalLength (same pos, zoom FOV)
function RenderSniperScope() {
    if (!activeScope) return;

    // Store main hiddeny reference for scope to restore
    var mainHiddeny = hiddeny;

    // Render functions to pass to scope module
    var renderFuncs = {
        DrawBackground: DrawBackground,
        RenderCube: RenderCube,
        Render: Render,
        RenderItems: RenderItems,
        RenderTestTarget: RenderTestTarget
    };

    // Call the active scope's render method
    activeScope.render(screendata, camera, renderFuncs, mainHiddeny);
}

// Switch between scope modes
function setScopeMode(mode) {
    scopeMode = mode;
    if (mode === 'forward') {
        activeScope = ScopeForwardPosition;
        document.getElementById('scopeModeForward').style.background = '#4CAF50';
        document.getElementById('scopeModeFocal').style.background = '#555';
        document.getElementById('scopeModeDesc').textContent = 'Camera moves forward (may clip through walls)';
    } else {
        activeScope = ScopeFocalLength;
        document.getElementById('scopeModeForward').style.background = '#555';
        document.getElementById('scopeModeFocal').style.background = '#4CAF50';
        document.getElementById('scopeModeDesc').textContent = 'Same position, focal length zoom (no wall clipping)';
    }
}

function Draw(timestamp){
    updaterunning=true;
    if(timestamp-lastFrameTime>=frameDuration){
        lastFrameTime=timestamp;
        pollGamepad();  // Check gamepad input
        if (typeof updateTouchInput === 'function') updateTouchInput();  // Mobile touch input
        UpdateCamera();
        updateTargetMetrics();  // Update test target metrics
        DrawBackground();
        RenderCube();   // 3D cube first - sets depth buffer
        Render();       // terrain respects cube's depth
        RenderItems();  // items into buffer with depth testing
        Flip();         // push buffer to screen
        RenderTestTarget();     // Test target circle
        RenderGroundWeapons();  // floating weapon pickups
        RenderGunViewmodel(screendata.context);  // first-person gun model
        RenderSniperScope();  // sniper scope picture-in-picture (covers screen when active)
        DrawMinimap();  // overlay minimap PiP
        DrawWeaponUI(screendata.context);  // weapon selection UI
        DrawTouchControls(screendata.context);  // Mobile touch joysticks
        DrawGunDebugInfo();     // Gun mechanics debug overlay
        frames++;
    }
    requestAnimationFrame(Draw);
}

// Minimap - top-down view with player triangle
function DrawMinimap(){
    if (!showMinimaps) return;  // Skip if minimaps disabled
    var ctx = screendata.context;
    var mmScale = uiScale.minimap;
    var size = Math.floor(200 * mmScale);  // minimap size in pixels (scaled)
    var range = minimapZoomRange;  // world units to show (adjustable via slider)
    var margin = Math.floor(10 * mmScale);
    var cx = screendata.canvas.width - size - margin;  // top-right corner
    var cy = margin;

    // Draw background
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(cx, cy, size, size);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.strokeRect(cx, cy, size, size);

    // Draw terrain colors from color map
    var scale = size / (range * 2);
    for(var py = 0; py < size; py += 2){
        for(var px = 0; px < size; px += 2){
            // Map screen pos to world pos
            var wx = camera.x + (px - size/2) / scale;
            var wy = camera.y + (py - size/2) / scale;

            // Sample color map
            var mapX = Math.floor(wx) & (map.width - 1);
            var mapY = Math.floor(wy) & (map.height - 1);
            var col = map.color[(mapY << map.shift) + mapX];

            // Extract RGB (stored as ABGR)
            var r = col & 0xFF;
            var g = (col >> 8) & 0xFF;
            var b = (col >> 16) & 0xFF;

            ctx.fillStyle = 'rgb('+r+','+g+','+b+')';
            ctx.fillRect(cx + px, cy + py, 2, 2);
        }
    }

    // Draw player as triangle pointing in look direction
    var pcx = cx + size/2;  // player center on minimap
    var pcy = cy + size/2;
    // Human proportions: shoulder width â 1/5 of total height, eye height â 93% of total
    var totalPlayerHeight = playerHeightOffset / 0.93;
    var playerWorldSize = totalPlayerHeight / 5;  // shoulder width in world units
    var triSize = Math.max(4, playerWorldSize * scale);  // scale to world units, min 4px
    var angle = camera.angle;

    ctx.save();
    ctx.translate(pcx, pcy);
    ctx.rotate(-angle);  // rotate to face direction

    ctx.beginPath();
    ctx.moveTo(0, -triSize);           // front point
    ctx.lineTo(-triSize * 0.6, triSize * 0.6);  // back left
    ctx.lineTo(triSize * 0.6, triSize * 0.6);   // back right
    ctx.closePath();

    ctx.fillStyle = 'yellow';
    ctx.fill();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.restore();

    // Draw FOV cone (scaled to actual camera horizontal FOV) - clipped to minimap bounds
    var hFov = DisplayConfig.fov.current * Math.PI / 180;  // horizontal FOV in radians
    var fovConeLength = 30 * scale;  // 30 world units range
    var fovHalfWidth = Math.tan(hFov / 2) * fovConeLength;  // half-width at end of cone
    ctx.save();
    // Clip to minimap rectangle so cone doesn't extend outside
    ctx.beginPath();
    ctx.rect(cx, cy, size, size);
    ctx.clip();
    ctx.translate(pcx, pcy);
    ctx.rotate(-angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-fovHalfWidth, -fovConeLength);
    ctx.lineTo(fovHalfWidth, -fovConeLength);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,0,0.2)';
    ctx.fill();
    ctx.restore();

    // Draw hitscan and CCD range circles (if enabled)
    if (showHitRanges) {
        // Hitscan range (red circle - instant hit zone)
        if (hitscanDistance > 0) {
            var hitscanRadius = hitscanDistance * scale;
            if (hitscanRadius < size / 2) {  // Only draw if fits on minimap
                ctx.beginPath();
                ctx.arc(pcx, pcy, hitscanRadius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // CCD max range (blue circle - projectile zone)
        var ccdRadius = ccdMaxDistance * scale;
        if (ccdRadius < size / 2) {  // Only draw if fits on minimap
            ctx.beginPath();
            ctx.arc(pcx, pcy, ccdRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(100, 170, 255, 0.6)';
            ctx.lineWidth = 1;
            ctx.setLineDash([10, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    // Draw bullets as red dots on minimap
    var bulletWorldRadius = bulletSize * 2;  // bullet radius in world units
    items.forEach(function(it){
        if(it.type === 'bullet'){
            var bx = (it.x - camera.x) * scale;
            var by = (it.y - camera.y) * scale;
            // Only draw if within minimap bounds
            if(Math.abs(bx) < size/2 && Math.abs(by) < size/2){
                ctx.beginPath();
                var bulletRadius = Math.max(2, bulletWorldRadius * scale);  // scale to world, min 2px
                ctx.arc(pcx + bx, pcy + by, bulletRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'red';
                ctx.fill();
            }
        }
    });

    // Draw test target on minimap (red circle with crosshair)
    if (testTarget.enabled) {
        var tx = (testTarget.x - camera.x) * scale;
        var ty = (testTarget.y - camera.y) * scale;
        if (Math.abs(tx) < size/2 && Math.abs(ty) < size/2) {
            var targetRadius = testTarget.radius * scale;
            // Outer ring
            ctx.beginPath();
            ctx.arc(pcx + tx, pcy + ty, targetRadius, 0, Math.PI * 2);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.stroke();
            // Inner dot
            ctx.beginPath();
            ctx.arc(pcx + tx, pcy + ty, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#ffff00';
            ctx.fill();
            // Crosshair
            ctx.beginPath();
            ctx.moveTo(pcx + tx - targetRadius, pcy + ty);
            ctx.lineTo(pcx + tx + targetRadius, pcy + ty);
            ctx.moveTo(pcx + tx, pcy + ty - targetRadius);
            ctx.lineTo(pcx + tx, pcy + ty + targetRadius);
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Draw view direction line (blue line - where camera is looking)
    var viewLineLen = 25 * scale;  // 25 world units
    ctx.save();
    ctx.translate(pcx, pcy);
    ctx.rotate(-angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(0, -viewLineLen);  // line pointing in look direction
    ctx.strokeStyle = 'rgba(0,100,255,0.7)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    // Draw barrel direction line (orange line - where gun is aiming)
    // Use actual gun direction from getGunWorldDirection()
    var gunDir = getGunWorldDirection();
    var barrelLineLen = 20 * scale;  // 20 world units
    ctx.beginPath();
    ctx.moveTo(pcx, pcy);
    ctx.lineTo(pcx + gunDir.x * barrelLineLen, pcy + gunDir.y * barrelLineLen);
    ctx.strokeStyle = 'orange';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw gun shape at barrel position
    var barrelPos = getBarrelWorldPos();
    var bpx = (barrelPos.x - camera.x) * scale;
    var bpy = (barrelPos.y - camera.y) * scale;
    if(Math.abs(bpx) < size/2 && Math.abs(bpy) < size/2){
        ctx.save();
        ctx.translate(pcx + bpx, pcy + bpy);
        // Rotate gun to match barrel direction
        var gunAngle = Math.atan2(-gunDir.y, -gunDir.x);
        ctx.rotate(gunAngle);

        // Draw gun shape (top-down silhouette) - realistic size from WeaponConfig
        var currentSlot = playerWeapons[currentWeaponIndex];
        var totalPlayerHeight = playerHeightOffset / 0.93;  // Convert eye height to total height
        var gunWorldLength = WeaponConfig.getWeaponLength(currentSlot.type, totalPlayerHeight);
        var pxPerUnit = scale;  // pixels per world unit on minimap
        var gunBodyLen = 0.5 * gunWorldLength * pxPerUnit;
        var gunBodyWidth = 0.25 * gunWorldLength * pxPerUnit;
        var barrelLen = 0.5 * gunWorldLength * pxPerUnit;
        var barrelWidth = 0.15 * gunWorldLength * pxPerUnit;
        // Ensure minimum visibility
        gunBodyLen = Math.max(gunBodyLen, 8);
        gunBodyWidth = Math.max(gunBodyWidth, 4);
        barrelLen = Math.max(barrelLen, 6);
        barrelWidth = Math.max(barrelWidth, 2);
        ctx.beginPath();
        // Gun body (rectangle)
        ctx.rect(-gunBodyLen * 0.6, -gunBodyWidth/2, gunBodyLen, gunBodyWidth);
        // Barrel (longer rectangle)
        ctx.rect(gunBodyLen * 0.3, -barrelWidth/2, barrelLen, barrelWidth);
        ctx.fillStyle = 'rgba(80,80,80,0.9)';
        ctx.fill();
        ctx.strokeStyle = 'cyan';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Barrel tip marker (cyan dot)
        var tipRadius = Math.max(2, 0.1 * gunWorldLength * pxPerUnit);
        ctx.beginPath();
        ctx.arc(gunBodyLen * 0.3 + barrelLen, 0, tipRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'cyan';
        ctx.fill();

        ctx.restore();
    }

    // Draw bullet spawn position (gray circle - where bullets actually spawn)
    var spawnX = barrelPos.x + gunDir.x * gunModel.barrelDistance;
    var spawnY = barrelPos.y + gunDir.y * gunModel.barrelDistance;
    var spx = (spawnX - camera.x) * scale;
    var spy = (spawnY - camera.y) * scale;
    var spawnRadius = Math.max(3, bulletSize * 2 * scale);  // scaled to world units
    if(Math.abs(spx) < size/2 && Math.abs(spy) < size/2){
        ctx.beginPath();
        ctx.arc(pcx + spx, pcy + spy, spawnRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#888';
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // Title with mode indicator
    ctx.fillStyle = 'white';
    ctx.font = '10px Arial';
    var modeText = gunModel.pivotMode === 'barrel' ? '[ADS]' : '[HIP]';
    ctx.fillText('OVERHEAD ' + modeText + ' [' + minimapZoomRange + '] Z=zoom', cx + 5, cy + 12);

    // === SIDE VIEW MINIMAP ===
    DrawSideView(ctx);

    // === LEGEND BOX ===
    DrawMinimapLegend(ctx);
}

// Side view showing terrain profile, player height, and bullets
function DrawSideView(ctx){
    var mmScale = uiScale.minimap;
    var width = Math.floor(200 * mmScale);   // minimap width (scaled)
    var height = Math.floor(80 * mmScale);   // minimap height (scaled)
    var margin = Math.floor(10 * mmScale);
    var sx = screendata.canvas.width - width - margin;  // top-right, below main minimap
    var sy = margin + Math.floor(210 * mmScale); // below the square minimap

    var rangeForward = sideViewZoomRange;  // world units to show forward (adjustable via slider)
    var rangeBack = Math.max(2, Math.floor(rangeForward / 6));  // world units to show behind
    var heightRange = Math.max(10, Math.floor(rangeForward / 2));  // world units of height to show

    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(sx, sy, width, height);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1;
    ctx.strokeRect(sx, sy, width, height);

    // Calculate look direction
    var fx = -Math.sin(camera.angle);
    var fy = -Math.cos(camera.angle);

    // Find min/max terrain height in view for scaling
    var minH = camera.height - Math.max(5, Math.floor(rangeForward / 6));
    var maxH = camera.height + Math.max(5, Math.floor(rangeForward / 3));

    // Calculate scale factors (pixels per world unit)
    var scaleX = width / (rangeForward + rangeBack);
    var scaleY = height / (maxH - minH);

    // Helper to convert world coords to screen coords
    function toScreen(dist, worldZ){
        var px = sx + ((dist + rangeBack) / (rangeForward + rangeBack)) * width;
        var py = sy + height - ((worldZ - minH) / (maxH - minH)) * height;
        return {x: px, y: py};
    }

    // Draw terrain profile (raw terrain without player height offset)
    ctx.beginPath();
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 2;
    var firstPoint = true;
    for(var d = -rangeBack; d <= rangeForward; d += 5){
        var wx = camera.x + fx * d;
        var wy = camera.y + fy * d;
        var terrainZ = getRawTerrainHeight(wx, wy);
        var p = toScreen(d, terrainZ);
        if(firstPoint){
            ctx.moveTo(p.x, p.y);
            firstPoint = false;
        } else {
            ctx.lineTo(p.x, p.y);
        }
    }
    ctx.stroke();

    // Fill terrain area
    ctx.lineTo(sx + width, sy + height);
    ctx.lineTo(sx, sy + height);
    ctx.closePath();
    ctx.fillStyle = 'rgba(100,100,100,0.5)';
    ctx.fill();

    // Draw raw ground level line at camera position (for reference)
    var rawGroundAtCam = getRawTerrainHeight(camera.x, camera.y);
    var groundLine = toScreen(0, rawGroundAtCam);
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    ctx.beginPath();
    ctx.moveTo(sx, groundLine.y);
    ctx.lineTo(sx + width, groundLine.y);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw player with proper human proportions
    // Human proportions: total height, head = 1/8, torso = 3/8, legs = 4/8
    var totalPlayerHeight = playerHeightOffset / 0.93;
    var headDiameter = totalPlayerHeight / 8;
    var torsoHeight = totalPlayerHeight * 3 / 8;
    var torsoWidth = totalPlayerHeight / 5;  // shoulder width
    var legLength = totalPlayerHeight * 4 / 8;

    // Calculate world Z positions (camera.height = eye level, eyes are ~40% down from head top)
    var headTopZ = camera.height + headDiameter * 0.4;
    var headBottomZ = camera.height - headDiameter * 0.6;  // chin/neck
    var torsoBottomZ = headBottomZ - torsoHeight;  // waist
    var feetZ = torsoBottomZ - legLength;  // feet position (moves with player)

    // Convert to screen coordinates
    var headCenter = toScreen(0, camera.height);
    var headRadius = Math.max(3, headDiameter * scaleY / 2);
    var torsoTop = toScreen(0, headBottomZ);
    var torsoBottom = toScreen(0, torsoBottomZ);
    var feetPos = toScreen(0, feetZ);
    var torsoWidthPx = Math.max(4, torsoWidth * scaleX);

    // Draw head (yellow circle)
    ctx.beginPath();
    ctx.arc(headCenter.x, headCenter.y, headRadius, 0, Math.PI * 2);
    ctx.fillStyle = 'yellow';
    ctx.fill();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Draw torso (yellow rectangle attached to bottom of head)
    // Screen Y is inverted: higher world Z = lower screen Y, so torsoBottom.y > torsoTop.y
    var torsoHeightPx = torsoBottom.y - torsoTop.y;
    ctx.fillStyle = 'yellow';
    ctx.fillRect(torsoTop.x - torsoWidthPx/2, torsoTop.y, torsoWidthPx, torsoHeightPx);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.strokeRect(torsoTop.x - torsoWidthPx/2, torsoTop.y, torsoWidthPx, torsoHeightPx);

    // Draw legs (two lines from waist to feet - fixed length, moves with player)
    var legWidth = Math.max(1, torsoWidthPx / 4);
    var legSpacing = torsoWidthPx / 3;
    ctx.strokeStyle = 'yellow';
    ctx.lineWidth = legWidth;
    // Left leg
    ctx.beginPath();
    ctx.moveTo(torsoBottom.x - legSpacing/2, torsoBottom.y);
    ctx.lineTo(feetPos.x - legSpacing/2, feetPos.y);
    ctx.stroke();
    // Right leg
    ctx.beginPath();
    ctx.moveTo(torsoBottom.x + legSpacing/2, torsoBottom.y);
    ctx.lineTo(feetPos.x + legSpacing/2, feetPos.y);
    ctx.stroke();

    // Draw max jump height indicator (green line from feet to max jump apex)
    // Physics: max height = vÂ²/(2g), with gravity ~0.5 and typical deltaTime, roughly jumpStrength * 1.2
    var maxJumpFeetZ = rawGroundAtCam + player.jumpMaxStrength * 1.2;  // max height feet can reach
    var jumpApex = toScreen(0, maxJumpFeetZ);
    // Vertical line from current feet to max jump feet position
    ctx.beginPath();
    ctx.moveTo(feetPos.x, feetPos.y);
    ctx.lineTo(jumpApex.x, jumpApex.y);
    ctx.strokeStyle = '#00ff88';  // light green (distinct from cyan gun)
    ctx.lineWidth = 1;
    ctx.stroke();
    // Horizontal tick at jump apex
    var tickWidth = 6;
    ctx.beginPath();
    ctx.moveTo(jumpApex.x - tickWidth, jumpApex.y);
    ctx.lineTo(jumpApex.x + tickWidth, jumpApex.y);
    ctx.strokeStyle = '#00ff88';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw vertical FOV cone (same as overhead view's horizontal cone)
    // Calculate actual vertical FOV from aspect ratio (16:9) and horizontal FOV
    var hFov = DisplayConfig.fov.current * Math.PI / 180;  // horizontal FOV in radians
    var aspectRatio = DisplayConfig.resolution.aspectRatio;
    var vFov = 2 * Math.atan(Math.tan(hFov / 2) / aspectRatio);  // vertical FOV in radians

    // Use accurate pitch calculation matching the camera projection
    var screenCenterY = screendata.canvas.height / 2;
    var fovPitch = Math.atan((camera.horizon - screenCenterY) / camera.focalLength);
    var fovConeRange = 30;  // world units for cone length (matches overhead view)

    // Calculate the top and bottom edges of the FOV cone
    var topAngle = fovPitch + vFov / 2;
    var bottomAngle = fovPitch - vFov / 2;

    var topEndZ = camera.height + Math.tan(topAngle) * fovConeRange;
    var bottomEndZ = camera.height + Math.tan(bottomAngle) * fovConeRange;

    var coneStart = toScreen(0, camera.height);
    var coneTopEnd = toScreen(fovConeRange, topEndZ);
    var coneBottomEnd = toScreen(fovConeRange, bottomEndZ);

    ctx.beginPath();
    ctx.moveTo(coneStart.x, coneStart.y);
    ctx.lineTo(coneTopEnd.x, coneTopEnd.y);
    ctx.lineTo(coneBottomEnd.x, coneBottomEnd.y);
    ctx.closePath();
    ctx.fillStyle = 'rgba(255,255,0,0.2)';
    ctx.fill();

    // Draw bullets as red dots with direction lines (scaled to world units)
    var bulletWorldSize = bulletSize * 2;  // bullet diameter in world units
    items.forEach(function(it){
        if(it.type === 'bullet'){
            // Calculate distance along look direction
            var dx = it.x - camera.x;
            var dy = it.y - camera.y;
            var dist = dx * fx + dy * fy;  // project onto look direction

            if(dist > -rangeBack && dist < rangeForward){
                var p = toScreen(dist, it.z);
                var bulletR = Math.max(2, bulletWorldSize * Math.min(scaleX, scaleY) / 2);
                ctx.beginPath();
                ctx.arc(p.x, p.y, bulletR, 0, Math.PI * 2);
                ctx.fillStyle = 'red';
                ctx.fill();
            }
        }
    });

    // Draw test target in side view
    if (testTarget.enabled) {
        var tdx = testTarget.x - camera.x;
        var tdy = testTarget.y - camera.y;
        var targetDist = tdx * fx + tdy * fy;  // distance along look direction

        if (targetDist > -rangeBack && targetDist < rangeForward) {
            var targetScreen = toScreen(targetDist, testTarget.z);
            var targetR = Math.max(4, testTarget.radius * Math.min(scaleX, scaleY));

            // Outer ring
            ctx.beginPath();
            ctx.arc(targetScreen.x, targetScreen.y, targetR, 0, Math.PI * 2);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Inner dot
            ctx.beginPath();
            ctx.arc(targetScreen.x, targetScreen.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#ffff00';
            ctx.fill();

            // Crosshair lines
            ctx.beginPath();
            ctx.moveTo(targetScreen.x - targetR, targetScreen.y);
            ctx.lineTo(targetScreen.x + targetR, targetScreen.y);
            ctx.moveTo(targetScreen.x, targetScreen.y - targetR);
            ctx.lineTo(targetScreen.x, targetScreen.y + targetR);
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Draw view direction (blue line - where you're looking/screen center)
    // Use accurate pitch calculation matching the camera projection
    var screenCenterY = screendata.canvas.height / 2;
    var viewPitch = Math.atan((camera.horizon - screenCenterY) / camera.focalLength);
    var viewEndDist = 200;
    var viewEndZ = camera.height + Math.tan(viewPitch) * viewEndDist;
    var viewStart = toScreen(0, camera.height);
    var viewEnd = toScreen(viewEndDist, viewEndZ);
    ctx.beginPath();
    ctx.moveTo(viewStart.x, viewStart.y);
    ctx.lineTo(viewEnd.x, viewEnd.y);
    ctx.strokeStyle = 'rgba(0,100,255,0.7)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Get gun barrel position in world space
    var barrelPos = getBarrelWorldPos();
    var gunDir = getGunWorldDirection();

    // Calculate gun distance along look direction
    var gunDx = barrelPos.x - camera.x;
    var gunDy = barrelPos.y - camera.y;
    var gunDist = gunDx * fx + gunDy * fy;

    // Calculate gun pitch based on pivot mode
    var gunPitch;
    var pivotScreenPos;
    var totalPlayerHeight = playerHeightOffset / 0.93;
    var gunWorldLength = WeaponConfig.getWeaponLength(playerWeapons[currentWeaponIndex].type, totalPlayerHeight);

    if (gunModel.pivotMode === 'barrel') {
        // ADS mode: gun follows view direction, pivot at barrel/spawn point
        gunPitch = -viewPitch;  // Gun matches camera pitch
        // Pivot point is at barrel position (forward from player)
        var pivotDist = gunModel.worldForward;
        var pivotZ = camera.height - gunModel.worldDown + Math.tan(viewPitch) * pivotDist;
        pivotScreenPos = toScreen(pivotDist, pivotZ);
    } else {
        // Hip fire mode: gun uses its own rotation, pivot at grip
        var horizontalDist = Math.sqrt(gunDir.x * gunDir.x + gunDir.y * gunDir.y);
        gunPitch = Math.atan2(-gunDir.z, horizontalDist);
        // Pivot point is at grip (back of gun, close to player)
        var gripDist = gunModel.worldForward - gunWorldLength * 0.4;  // grip is back from barrel
        var gripZ = camera.height - gunModel.worldDown;
        pivotScreenPos = toScreen(gripDist, gripZ);
    }

    // Draw gun shape (side view silhouette) at pivot point
    var gunScreen = pivotScreenPos;

    ctx.save();
    ctx.translate(gunScreen.x, gunScreen.y);
    ctx.rotate(gunPitch);

    // Draw gun shape (side silhouette) - realistic size from WeaponConfig
    var currentSlot = playerWeapons[currentWeaponIndex];
    var totalPlayerHeight = playerHeightOffset / 0.93;  // Convert eye height to total height
    var gunWorldLength = WeaponConfig.getWeaponLength(currentSlot.type, totalPlayerHeight);
    var pxPerUnit = Math.min(scaleX, scaleY);  // pixels per world unit on side view
    var gunBodyLen = 0.5 * gunWorldLength * pxPerUnit;
    var gunBodyH = 0.3 * gunWorldLength * pxPerUnit;
    var barrelLen = 0.5 * gunWorldLength * pxPerUnit;
    var barrelH = 0.15 * gunWorldLength * pxPerUnit;
    var gripLen = 0.2 * gunWorldLength * pxPerUnit;
    var gripH = 0.35 * gunWorldLength * pxPerUnit;
    // Ensure minimum visibility
    gunBodyLen = Math.max(gunBodyLen, 6);
    gunBodyH = Math.max(gunBodyH, 3);
    barrelLen = Math.max(barrelLen, 5);
    barrelH = Math.max(barrelH, 2);
    gripLen = Math.max(gripLen, 3);
    gripH = Math.max(gripH, 4);
    ctx.beginPath();
    // Gun body
    ctx.rect(-gunBodyLen * 0.7, -gunBodyH/2, gunBodyLen, gunBodyH);
    // Barrel
    ctx.rect(gunBodyLen * 0.3, -barrelH/2, barrelLen, barrelH);
    // Grip
    ctx.rect(-gunBodyLen * 0.4, gunBodyH/2, gripLen, gripH);
    ctx.fillStyle = 'rgba(80,80,80,0.9)';
    ctx.fill();
    ctx.strokeStyle = 'cyan';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Barrel tip marker
    var tipR = Math.max(2, 0.05 * gunWorldLength * pxPerUnit);
    ctx.beginPath();
    ctx.arc(gunBodyLen * 0.3 + barrelLen, 0, tipR, 0, Math.PI * 2);
    ctx.fillStyle = 'cyan';
    ctx.fill();

    ctx.restore();

    // Calculate bullet spawn position (offset from barrel by barrelDistance)
    var bulletSpawnX = barrelPos.x + gunDir.x * gunModel.barrelDistance;
    var bulletSpawnY = barrelPos.y + gunDir.y * gunModel.barrelDistance;
    var bulletSpawnZ = barrelPos.z + gunDir.z * gunModel.barrelDistance;
    var bulletDx = bulletSpawnX - camera.x;
    var bulletDy = bulletSpawnY - camera.y;
    var bulletDist = bulletDx * fx + bulletDy * fy;

    // Draw bullet spawn position (gray dot) - scaled to world units
    var spawnR = Math.max(3, bulletSize * 2 * Math.min(scaleX, scaleY));
    var bulletScreen = toScreen(bulletDist, bulletSpawnZ);
    ctx.beginPath();
    ctx.arc(bulletScreen.x, bulletScreen.y, spawnR, 0, Math.PI * 2);
    ctx.fillStyle = '#888';
    ctx.fill();
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Draw line from gun to bullet spawn
    ctx.beginPath();
    ctx.moveTo(gunScreen.x, gunScreen.y);
    ctx.lineTo(bulletScreen.x, bulletScreen.y);
    ctx.strokeStyle = 'rgba(255,100,100,0.7)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw barrel direction line (orange - where bullets will go)
    var barrelEndDist = 200;  // world units ahead
    var barrelEndZ;

    if (gunModel.pivotMode === 'barrel') {
        // ADS mode: use ACTUAL shooting pitch (same formula as bullet spawn)
        // Bullets go toward screen center, not horizon-based pitch
        var screenCenterY = screendata.canvas.height / 2;
        var aimPitch = Math.atan((camera.horizon - screenCenterY) / camera.focalLength);
        barrelEndZ = barrelPos.z + Math.tan(aimPitch) * barrelEndDist;
    } else {
        // Hip fire mode: barrel follows gun's own direction
        var barrelFwdComponent = gunDir.x * fx + gunDir.y * fy;
        barrelEndZ = barrelPos.z + (-gunDir.z / Math.abs(barrelFwdComponent || 0.01)) * barrelEndDist;
    }
    var barrelStart = toScreen(gunDist, barrelPos.z);
    var barrelEnd = toScreen(gunDist + barrelEndDist, barrelEndZ);
    ctx.beginPath();
    ctx.moveTo(barrelStart.x, barrelStart.y);
    ctx.lineTo(barrelEnd.x, barrelEnd.y);
    ctx.strokeStyle = 'orange';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw pivot point marker (magenta diamond)
    var pivotSize = 4;
    ctx.beginPath();
    ctx.moveTo(pivotScreenPos.x, pivotScreenPos.y - pivotSize);
    ctx.lineTo(pivotScreenPos.x + pivotSize, pivotScreenPos.y);
    ctx.lineTo(pivotScreenPos.x, pivotScreenPos.y + pivotSize);
    ctx.lineTo(pivotScreenPos.x - pivotSize, pivotScreenPos.y);
    ctx.closePath();
    ctx.fillStyle = '#ff00ff';  // magenta
    ctx.fill();
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Title with mode indicator
    ctx.fillStyle = 'white';
    ctx.font = '10px Arial';
    var modeText = gunModel.pivotMode === 'barrel' ? '[ADS]' : '[HIP]';
    ctx.fillText('SIDE VIEW ' + modeText + ' [' + sideViewZoomRange + '] Z=zoom', sx + 5, sy + 12);
}

// Legend box below side view (shared by both minimaps)
function DrawMinimapLegend(ctx){
    var mmScale = uiScale.minimap;
    var width = Math.floor(200 * mmScale);
    var height = Math.floor(86 * mmScale);  // increased for 5 rows
    var margin = Math.floor(10 * mmScale);
    var lx = screendata.canvas.width - width - margin;
    var ly = margin + Math.floor((210 + 80 + 5) * mmScale);  // below side view (scaled)

    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(lx, ly, width, height);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1;
    ctx.strokeRect(lx, ly, width, height);

    // Legend items in two columns
    ctx.font = '10px Arial';
    var col1 = lx + 10;
    var col2 = lx + 105;
    var row1 = ly + 14;
    var row2 = ly + 28;
    var row3 = ly + 42;
    var row4 = ly + 56;
    var row5 = ly + 70;

    ctx.fillStyle = 'yellow';
    ctx.fillText('âplayer', col1, row1);
    ctx.fillStyle = 'red';
    ctx.fillText('âbullet', col2, row1);

    ctx.fillStyle = 'cyan';
    ctx.fillText('â gun', col1, row2);
    ctx.fillStyle = 'orange';
    ctx.fillText('âaim', col2, row2);

    ctx.fillStyle = '#888';
    ctx.fillText('âspawn', col1, row3);
    ctx.fillStyle = 'rgba(0,100,255,1)';
    ctx.fillText('âview', col2, row3);

    ctx.fillStyle = '#00ff88';
    ctx.fillText('|jump', col1, row4);
    ctx.fillStyle = '#ff00ff';
    ctx.fillText('âpivot', col2, row4);

    // Show current mode
    ctx.fillStyle = 'white';
    ctx.fillText(gunModel.pivotMode === 'barrel' ? 'Mode: ADS' : 'Mode: Hip', col1, row5);
}

// Render ground weapons as floating 3D icons
function RenderGroundWeapons() {
    var ctx = screendata.context;
    var sw = screendata.canvas.width;
    var sh = screendata.canvas.height;
    var sinYaw = Math.sin(camera.angle);
    var cosYaw = Math.cos(camera.angle);

    groundWeapons.forEach(function(gw) {
        var wep = weapons[gw.type];
        var dx = gw.x - camera.x;
        var dy = gw.y - camera.y;

        // Ground-plane distance
        var groundForward = -dx * sinYaw - dy * cosYaw;
        if (groundForward < 1 || groundForward > camera.distance) return;

        // Right offset
        var right = dx * cosYaw - dy * sinYaw;

        // Screen position (floating above ground)
        var floatHeight = gw.z + 20 + Math.sin(Date.now() / 300) * 5;  // Bob up and down
        var screenX = right * (sw / 2) / groundForward + sw / 2;
        var screenY = (camera.height - floatHeight) * camera.focalLength / groundForward + camera.horizon;

        // Size based on distance
        var size = 300 / groundForward;
        size = Math.max(15, Math.min(50, size));

        // Draw rounded rectangle with weapon letter
        var cornerRadius = size / 5;
        ctx.beginPath();
        ctx.roundRect(screenX - size/2, screenY - size/2, size, size, cornerRadius);
        ctx.fillStyle = wep.bgColor;
        ctx.fill();
        ctx.strokeStyle = wep.color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw letter
        ctx.fillStyle = wep.color;
        ctx.font = 'bold ' + Math.floor(size * 0.6) + 'px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(wep.letter, screenX, screenY);
    });

    ctx.textAlign = 'left';  // Reset
}

// Draw weapon UI - shows current weapons and pickup prompt
function DrawWeaponUI(ctx) {
    var sw = screendata.canvas.width;
    var sh = screendata.canvas.height;
    var wuScale = uiScale.weaponUI;
    var iconSize = Math.floor(40 * wuScale);
    var iconMargin = Math.floor(5 * wuScale);
    var cornerRadius = Math.floor(8 * wuScale);

    // Draw weapon slots at bottom center
    var startX = sw / 2 - iconSize - iconMargin;
    var startY = sh - iconSize - Math.floor(15 * wuScale);

    // Clear weapon slot hitboxes for touch controls
    touchControls.weaponSlots = [];

    for (var i = 0; i < 2; i++) {
        var slot = playerWeapons[i];
        var wep = weapons[slot.type];
        var x = startX + i * (iconSize + iconMargin * 2);
        var y = startY;

        // Store hitbox for touch detection
        touchControls.weaponSlots.push({ x: x, y: y, w: iconSize, h: iconSize, index: i });

        // Draw rounded rectangle background
        ctx.beginPath();
        ctx.roundRect(x, y, iconSize, iconSize, cornerRadius);
        ctx.fillStyle = wep.bgColor;
        ctx.fill();

        // Highlight current weapon
        if (i === currentWeaponIndex) {
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
        } else {
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Draw weapon letter
        ctx.fillStyle = wep.color;
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(wep.letter, x + iconSize/2, y + iconSize/2);

        // Draw ammo count below
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.fillText(slot.ammo + '/' + wep.maxMagazine, x + iconSize/2, y + iconSize + 10);
    }

    // Draw swap hint (show tap hint on touch devices)
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(touchControls.enabled ? 'Tap to swap' : 'Q to swap', sw/2, startY - 5);

    // Clear pickup hitbox
    touchControls.pickupHitbox = null;

    // Draw pickup prompt if near a ground weapon
    if (nearbyWeapon) {
        var gwep = weapons[nearbyWeapon.type];
        var promptY = sh / 2 + 50;
        var pickupBoxWidth = iconSize + 100;
        var pickupBoxHeight = iconSize + 30;

        // Store hitbox for touch detection (larger area for easier tapping)
        touchControls.pickupHitbox = {
            x: sw/2 - pickupBoxWidth/2,
            y: promptY - 10,
            w: pickupBoxWidth,
            h: pickupBoxHeight
        };

        // Draw weapon icon
        ctx.beginPath();
        ctx.roundRect(sw/2 - iconSize/2, promptY, iconSize, iconSize, cornerRadius);
        ctx.fillStyle = gwep.bgColor;
        ctx.fill();
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = gwep.color;
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(gwep.letter, sw/2, promptY + iconSize/2);

        // Draw pickup text (show tap hint on touch devices)
        ctx.fillStyle = 'yellow';
        ctx.font = '14px Arial';
        var pickupText = touchControls.enabled ? 'Tap to pick up ' + gwep.name : 'Press E to pick up ' + gwep.name;
        ctx.fillText(pickupText, sw/2, promptY + iconSize + 15);
    }

    ctx.textAlign = 'left';  // Reset
}

// Draw mobile touch controls (virtual joysticks and shoot button)
function DrawTouchControls(ctx) {
    if (!touchControls.enabled) return;

    var sw = screendata.canvas.width;
    var sh = screendata.canvas.height;
    var r = touchControls.stickRadius;

    // Update positions on resize
    touchControls.leftStickPos = { x: r + 30, y: sh - r - 100 };
    touchControls.rightStickPos = { x: sw - r - 30, y: sh - r - 100 };
    touchControls.shootButton.x = sw - 80;
    touchControls.shootButton.y = sh - 200;

    ctx.globalAlpha = 0.4;

    // Draw left stick (movement)
    var lx = touchControls.leftStick.active ? touchControls.leftStick.startX : touchControls.leftStickPos.x;
    var ly = touchControls.leftStick.active ? touchControls.leftStick.startY : touchControls.leftStickPos.y;

    // Outer circle
    ctx.beginPath();
    ctx.arc(lx, ly, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
    ctx.fill();

    // Inner stick position
    var lsx = lx, lsy = ly;
    if (touchControls.leftStick.active) {
        var dx = touchControls.leftStick.currentX - touchControls.leftStick.startX;
        var dy = touchControls.leftStick.currentY - touchControls.leftStick.startY;
        var dist = Math.hypot(dx, dy);
        if (dist > r) {
            dx = dx / dist * r;
            dy = dy / dist * r;
        }
        lsx = lx + dx;
        lsy = ly + dy;
    }
    ctx.beginPath();
    ctx.arc(lsx, lsy, r * 0.4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.fill();

    // Label
    ctx.fillStyle = 'white';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('MOVE', lx, ly - r - 10);

    // Draw right stick (look)
    var rx = touchControls.rightStick.active ? touchControls.rightStick.startX : touchControls.rightStickPos.x;
    var ry = touchControls.rightStick.active ? touchControls.rightStick.startY : touchControls.rightStickPos.y;

    // Outer circle
    ctx.beginPath();
    ctx.arc(rx, ry, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
    ctx.fill();

    // Inner stick position
    var rsx = rx, rsy = ry;
    if (touchControls.rightStick.active) {
        var dx = touchControls.rightStick.currentX - touchControls.rightStick.startX;
        var dy = touchControls.rightStick.currentY - touchControls.rightStick.startY;
        var dist = Math.hypot(dx, dy);
        if (dist > r) {
            dx = dx / dist * r;
            dy = dy / dist * r;
        }
        rsx = rx + dx;
        rsy = ry + dy;
    }
    ctx.beginPath();
    ctx.arc(rsx, rsy, r * 0.4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    ctx.fill();

    // Label
    ctx.fillText('LOOK', rx, ry - r - 10);

    // Draw shoot button
    var sb = touchControls.shootButton;
    ctx.beginPath();
    ctx.arc(sb.x, sb.y, sb.radius, 0, Math.PI * 2);
    ctx.fillStyle = sb.active ? 'rgba(255, 0, 0, 0.6)' : 'rgba(255, 100, 100, 0.4)';
    ctx.fill();
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.fillStyle = 'white';
    ctx.font = 'bold 14px Arial';
    ctx.fillText('FIRE', sb.x, sb.y + 5);

    ctx.globalAlpha = 1.0;
    ctx.textAlign = 'left';
}

// ===============================
function DownloadImagesAsync(urls){
    return new Promise(function(resolve){
        var pending=urls.length,result=[];if(!pending){resolve([]);return;}
        urls.forEach(function(url,i){var img=new Image();img.onload=function(){var tcv=document.createElement("canvas"),tcx=tcv.getContext("2d");tcv.width=map.width;tcv.height=map.height;tcx.drawImage(img,0,0,map.width,map.height);result[i]=tcx.getImageData(0,0,map.width,map.height).data;pending--;if(!pending)resolve(result);};img.src=url;});
    });
}
function LoadMap(files){var f=files.split(";");DownloadImagesAsync(["maps/"+f[0]+".png","maps/"+f[1]+".png"]).then(OnLoadedImages);}



function OnLoadedImages(result){
    var datac = result[0], datah = result[1];
    for (var i = 0; i < map.width * map.height; i++) {
        map.color[i] = 0xFF000000 |
                       (datac[(i<<2)+2] << 16) |
                       (datac[(i<<2)+1] << 8) |
                        datac[(i<<2)+0];
        map.altitude[i] = datah[i<<2];
    }

    // Flatten terrain under the cube
    flattenTerrainUnderCube();

    // Start draw loop
    Draw();
}

// Flatten terrain within the cube's footprint to prevent terrain poking through
function flattenTerrainUnderCube() {
    var s = cube.size;
    var minX = Math.floor(cube.x - s/2);
    var maxX = Math.ceil(cube.x + s/2);
    var minY = Math.floor(cube.y - s/2);
    var maxY = Math.ceil(cube.y + s/2);

    // Find the minimum height within the cube's footprint
    var minHeight = 255;
    for (var y = minY; y <= maxY; y++) {
        for (var x = minX; x <= maxX; x++) {
            var mx = x & (map.width - 1);
            var my = y & (map.height - 1);
            var idx = (my << map.shift) + mx;
            if (map.altitude[idx] < minHeight) {
                minHeight = map.altitude[idx];
            }
        }
    }

    // Set all terrain within cube footprint to that minimum height
    for (var y = minY; y <= maxY; y++) {
        for (var x = minX; x <= maxX; x++) {
            var mx = x & (map.width - 1);
            var my = y & (map.height - 1);
            var idx = (my << map.shift) + mx;
            map.altitude[idx] = minHeight;
        }
    }

    // Add one fixed heart as a test
    items.push({
        type: "heart",
        x: 20, y: 110, z: getGroundHeight(20,110)+50,
        dx: 0, dy: 0, dz: 0,
        image: textures.heart
    });

    // Spawn a pistol on the ground near player start
    groundWeapons.push({
        type: "pistol",
        x: 40,
        y: 40,
        z: getRawTerrainHeight(40, 40)
    });

    // ð³ Spawn random trees on green-ish terrain
    spawnRandomItems("tree", textures.tree, {
        step: 8,         // check every 8 pixels
        chance: 0.01,    // 1% chance
        colorCheck: (col) => ((col & 0x00FF00) > 0x004000) // must be green-ish
    });


}

// Apply UI scale transforms to HUD elements
function applyUIScales() {
    var crosshair = document.getElementById('crosshair');
    var healthbar = document.getElementById('healthbar');
    var jumpbar = document.getElementById('jumpbar');

    // Crosshair - scale from center
    if (crosshair) {
        var cs = uiScale.crosshair;
        crosshair.style.width = (10 * cs) + 'px';
        crosshair.style.height = (10 * cs) + 'px';
        crosshair.style.margin = (-5 * cs) + 'px 0 0 ' + (-5 * cs) + 'px';
    }

    // Health bar - scale from bottom-left
    if (healthbar) {
        var hs = uiScale.healthbar;
        healthbar.style.width = (200 * hs) + 'px';
        healthbar.style.height = (20 * hs) + 'px';
        healthbar.style.bottom = (10 * hs) + 'px';
        healthbar.style.left = (10 * hs) + 'px';
        healthbar.style.borderWidth = (2 * hs) + 'px';
    }

    // Jump bar - scale from bottom-left
    if (jumpbar) {
        var js = uiScale.jumpbar;
        jumpbar.style.width = (200 * js) + 'px';
        jumpbar.style.height = (10 * js) + 'px';
        jumpbar.style.bottom = (40 * js) + 'px';
        jumpbar.style.left = (10 * js) + 'px';
        jumpbar.style.borderWidth = (2 * js) + 'px';
    }
}

function OnResizeWindow(){
    screendata.canvas=document.getElementById('fullscreenCanvas');
    var gameContainer = document.getElementById('game-container');

    // Use display config for resolution (16:9 locked)
    var dims = DisplayConfig.getCanvasDimensions(window.innerWidth, window.innerHeight);

    // Position and size the game container (holds canvas + HUD)
    gameContainer.style.width = dims.canvasWidth + 'px';
    gameContainer.style.height = dims.canvasHeight + 'px';
    gameContainer.style.left = ((window.innerWidth - dims.canvasWidth) / 2) + 'px';
    gameContainer.style.top = ((window.innerHeight - dims.canvasHeight) / 2) + 'px';

    // Set canvas render resolution (internal)
    screendata.canvas.width = dims.renderWidth;
    screendata.canvas.height = dims.renderHeight;

    if(screendata.canvas.getContext){
        screendata.context=screendata.canvas.getContext('2d');
        screendata.imagedata=screendata.context.createImageData(screendata.canvas.width,screendata.canvas.height);
    }
    screendata.bufarray=new ArrayBuffer(screendata.imagedata.width*screendata.imagedata.height*4);
    screendata.buf8=new Uint8Array(screendata.bufarray);
    screendata.buf32=new Uint32Array(screendata.bufarray);
    screendata.depthBuffer=new Float32Array(screendata.canvas.width*screendata.canvas.height);
    hiddeny=new Int32Array(screendata.canvas.width);
}
function Init(){
    for(var i=0;i<map.width*map.height;i++){map.color[i]=0xFF007050;map.altitude[i]=0;}
    LoadMap("CE;DE");OnResizeWindow();
    loadGunModel();  // Load first-person gun model
    // Note: Press T to position test target after map loads
    var canvas=document.getElementById("fullscreenCanvas");

    // Tab switching for controls panel
    document.querySelectorAll('.tab-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
            var tabId = this.getAttribute('data-tab');
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(function(tab) {
                tab.style.display = 'none';
            });
            // Deactivate all buttons
            document.querySelectorAll('.tab-btn').forEach(function(b) {
                b.style.background = '#333';
                b.style.color = '#aaa';
            });
            // Show selected tab
            document.getElementById('tab-' + tabId).style.display = 'block';
            // Activate button
            this.style.background = '#555';
            this.style.color = 'white';
        });
    });
    // Initialize scope mode (default to forward position)
    setScopeMode('forward');

    // Scope mode toggle buttons
    document.getElementById('scopeModeForward').addEventListener('click', function() {
        setScopeMode('forward');
    });
    document.getElementById('scopeModeFocal').addEventListener('click', function() {
        setScopeMode('focal');
    });

    window.onkeydown=DetectKeysDown;window.onkeyup=DetectKeysUp;
    canvas.onmousedown=DetectMouseDown;canvas.onmouseup=DetectMouseUp;
    canvas.onwheel=DetectMouseWheel;  // Mouse wheel for sniper scope zoom
    canvas.oncontextmenu=function(e){e.preventDefault();return false;}; // Disable right-click menu
    window.onresize=OnResizeWindow;
    canvas.requestPointerLock=canvas.requestPointerLock||canvas.mozRequestPointerLock;
    canvas.onclick=function(){canvas.requestPointerLock();};
    document.addEventListener('pointerlockchange',function(){
        if(document.pointerLockElement===canvas||document.mozPointerLockElement===canvas){canvas.onmousemove=DetectMouseMove;}
        else{canvas.onmousemove=null;}
    },false);

    // Mobile touch controls
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
    canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });

    // Detect touch device and enable touch controls
    function enableTouchControls() {
        touchControls.enabled = true;
        updateTouchControlPositions();
    }

    function updateTouchControlPositions() {
        var sw = screendata.canvas.width;
        var sh = screendata.canvas.height;
        var r = touchControls.stickRadius;
        touchControls.leftStickPos = { x: r + 30, y: sh - r - 100 };
        touchControls.rightStickPos = { x: sw - r - 30, y: sh - r - 100 };
        touchControls.shootButton = { x: sw - 80, y: sh - 200, radius: 40, active: false, touchId: null };
    }

    function handleTouchStart(e) {
        e.preventDefault();
        if (!touchControls.enabled) enableTouchControls();

        for (var i = 0; i < e.changedTouches.length; i++) {
            var touch = e.changedTouches[i];
            var x = touch.clientX;
            var y = touch.clientY;
            var sw = screendata.canvas.width;

            // Check weapon slot touches
            for (var j = 0; j < touchControls.weaponSlots.length; j++) {
                var slot = touchControls.weaponSlots[j];
                if (x >= slot.x && x <= slot.x + slot.w && y >= slot.y && y <= slot.y + slot.h) {
                    if (slot.index !== currentWeaponIndex) {
                        // Swap to this weapon
                        currentWeaponIndex = slot.index;
                    }
                    return;
                }
            }

            // Check pickup hitbox
            if (touchControls.pickupHitbox && nearbyWeapon) {
                var ph = touchControls.pickupHitbox;
                if (x >= ph.x && x <= ph.x + ph.w && y >= ph.y && y <= ph.y + ph.h) {
                    input.pickupWeapon = true;
                    setTimeout(function() { input.pickupWeapon = false; }, 100);
                    return;
                }
            }

            // Check shoot button
            var sb = touchControls.shootButton;
            var distToShoot = Math.hypot(x - sb.x, y - sb.y);
            if (distToShoot < sb.radius) {
                sb.active = true;
                sb.touchId = touch.identifier;
                input.shoot = true;
                continue;
            }

            // Left half = movement stick, Right half = look stick
            if (x < sw / 2) {
                if (!touchControls.leftStick.active) {
                    touchControls.leftStick.active = true;
                    touchControls.leftStick.touchId = touch.identifier;
                    touchControls.leftStick.startX = x;
                    touchControls.leftStick.startY = y;
                    touchControls.leftStick.currentX = x;
                    touchControls.leftStick.currentY = y;
                }
            } else {
                if (!touchControls.rightStick.active) {
                    touchControls.rightStick.active = true;
                    touchControls.rightStick.touchId = touch.identifier;
                    touchControls.rightStick.startX = x;
                    touchControls.rightStick.startY = y;
                    touchControls.rightStick.currentX = x;
                    touchControls.rightStick.currentY = y;
                }
            }
        }
    }

    function handleTouchMove(e) {
        e.preventDefault();
        for (var i = 0; i < e.changedTouches.length; i++) {
            var touch = e.changedTouches[i];

            if (touchControls.leftStick.active && touch.identifier === touchControls.leftStick.touchId) {
                touchControls.leftStick.currentX = touch.clientX;
                touchControls.leftStick.currentY = touch.clientY;
            }
            if (touchControls.rightStick.active && touch.identifier === touchControls.rightStick.touchId) {
                touchControls.rightStick.currentX = touch.clientX;
                touchControls.rightStick.currentY = touch.clientY;
            }
        }
    }

    function handleTouchEnd(e) {
        for (var i = 0; i < e.changedTouches.length; i++) {
            var touch = e.changedTouches[i];

            if (touchControls.leftStick.touchId === touch.identifier) {
                touchControls.leftStick.active = false;
                touchControls.leftStick.touchId = null;
                input.moveX = 0;
                input.moveY = 0;
            }
            if (touchControls.rightStick.touchId === touch.identifier) {
                touchControls.rightStick.active = false;
                touchControls.rightStick.touchId = null;
            }
            if (touchControls.shootButton.touchId === touch.identifier) {
                touchControls.shootButton.active = false;
                touchControls.shootButton.touchId = null;
                input.shoot = false;
            }
        }
    }

    // Update touch input each frame
    function updateTouchInput() {
        if (!touchControls.enabled) return;

        var ls = touchControls.leftStick;
        var rs = touchControls.rightStick;
        var r = touchControls.stickRadius;
        var dz = touchControls.stickDeadzone;

        // Left stick - movement
        if (ls.active) {
            var dx = ls.currentX - ls.startX;
            var dy = ls.currentY - ls.startY;
            var dist = Math.hypot(dx, dy);
            if (dist > dz) {
                var norm = Math.min(dist, r) / r;
                input.moveX = (dx / dist) * norm;
                input.moveY = (dy / dist) * norm;
            } else {
                input.moveX = 0;
                input.moveY = 0;
            }
        }

        // Right stick - look
        if (rs.active) {
            var dx = rs.currentX - rs.startX;
            var dy = rs.currentY - rs.startY;
            var dist = Math.hypot(dx, dy);
            if (dist > dz) {
                var sensitivity = 0.003;
                camera.angle += dx * sensitivity;
                camera.pitch -= dy * sensitivity * 0.5;
                camera.pitch = Math.max(-1.2, Math.min(1.2, camera.pitch));
                // Reset start position for continuous look
                rs.startX = rs.currentX;
                rs.startY = rs.currentY;
            }
        }
    }

    setInterval(function(){var current=Date.now();document.getElementById('debug-fps').innerText=(frames/(current-timelastframe)*1000).toFixed(1)+" fps";frames=0;timelastframe=current;},2000);

    // Camera FOV slider (focal length - higher = narrower FOV)
    document.getElementById('fov').addEventListener('input', function(e){
        camera.baseFocalLength = parseInt(e.target.value);
        camera.focalLength = camera.baseFocalLength;
        document.getElementById('fov-value').innerText = camera.baseFocalLength;
    });

    // Pitch offset slider
    document.getElementById('pitchOffset').addEventListener('input', function(e){
        pitchOffset = parseInt(e.target.value);
        document.getElementById('pitchOffset-value').innerText = pitchOffset;
    });

    // Target FPS slider
    document.getElementById('targetFPS').addEventListener('input', function(e){
        targetFPS = parseInt(e.target.value);
        frameDuration = 1000 / targetFPS;
        document.getElementById('targetFPS-value').innerText = targetFPS;
    });

    // Player height slider
    document.getElementById('playerHeight').addEventListener('input', function(e){
        playerHeightOffset = parseInt(e.target.value);
        document.getElementById('playerHeight-value').innerText = playerHeightOffset;
    });

    // Standing height slider
    document.getElementById('normalHeight').addEventListener('input', function(e){
        player.normalHeight = parseInt(e.target.value);
        document.getElementById('normalHeight-value').innerText = player.normalHeight;
    });

    // Crouch height slider
    document.getElementById('crouchHeight').addEventListener('input', function(e){
        player.crouchHeight = parseInt(e.target.value);
        document.getElementById('crouchHeight-value').innerText = player.crouchHeight;
    });

    // Jump min strength slider
    document.getElementById('jumpMin').addEventListener('input', function(e){
        player.jumpMinStrength = parseInt(e.target.value);
        document.getElementById('jumpMin-value').innerText = player.jumpMinStrength;
    });

    // Jump max strength slider
    document.getElementById('jumpMax').addEventListener('input', function(e){
        player.jumpMaxStrength = parseInt(e.target.value);
        document.getElementById('jumpMax-value').innerText = player.jumpMaxStrength;
    });

    // Walk speed slider
    document.getElementById('walkSpeed').addEventListener('input', function(e){
        player.moveSpeed = parseFloat(e.target.value);
        document.getElementById('walkSpeed-value').innerText = player.moveSpeed.toFixed(1);
    });

    // Sprint multiplier slider
    document.getElementById('sprintMultiplier').addEventListener('input', function(e){
        player.sprintMultiplier = parseFloat(e.target.value);
        document.getElementById('sprintMultiplier-value').innerText = player.sprintMultiplier.toFixed(1);
    });

    // Shared edit mode for Gun and Barrel tabs: 'ads' or 'hip'
    var editMode = 'ads';

    // Function to update gun sliders to show current mode's values
    function updateGunSliders() {
        var prefix = editMode === 'ads' ? 'ads' : 'hip';
        document.getElementById('gunX').value = gunModel[prefix + 'OffsetX'];
        document.getElementById('gunX-value').innerText = gunModel[prefix + 'OffsetX'];
        document.getElementById('gunY').value = gunModel[prefix + 'OffsetY'];
        document.getElementById('gunY-value').innerText = gunModel[prefix + 'OffsetY'];
        document.getElementById('gunZ').value = gunModel[prefix + 'OffsetZ'];
        document.getElementById('gunZ-value').innerText = gunModel[prefix + 'OffsetZ'];
        document.getElementById('gunScale').value = gunModel[prefix + 'Scale'];
        document.getElementById('gunScale-value').innerText = gunModel[prefix + 'Scale'];
        document.getElementById('gunRotX').value = gunModel[prefix + 'RotationX'];
        document.getElementById('gunRotX-value').innerText = gunModel[prefix + 'RotationX'];
        document.getElementById('gunRotY').value = gunModel[prefix + 'RotationY'];
        document.getElementById('gunRotY-value').innerText = gunModel[prefix + 'RotationY'];
        document.getElementById('gunRotZ').value = gunModel[prefix + 'RotationZ'];
        document.getElementById('gunRotZ-value').innerText = gunModel[prefix + 'RotationZ'];
    }

    // Function to update barrel sliders to show current mode's values
    function updateBarrelSliders() {
        var prefix = editMode === 'ads' ? 'ads' : 'hip';
        document.getElementById('barrelYaw').value = gunModel[prefix + 'BarrelYaw'];
        document.getElementById('barrelYaw-value').innerText = gunModel[prefix + 'BarrelYaw'];
        document.getElementById('barrelX').value = gunModel[prefix + 'BarrelX'];
        document.getElementById('barrelX-value').innerText = gunModel[prefix + 'BarrelX'].toFixed(2);
        document.getElementById('barrelY').value = gunModel[prefix + 'BarrelY'];
        document.getElementById('barrelY-value').innerText = gunModel[prefix + 'BarrelY'].toFixed(2);
        document.getElementById('barrelZ').value = gunModel[prefix + 'BarrelZ'];
        document.getElementById('barrelZ-value').innerText = gunModel[prefix + 'BarrelZ'].toFixed(2);
    }

    // Function to update world offset sliders to show current mode's values
    function updateWorldOffsetSliders() {
        var prefix = editMode === 'ads' ? 'ads' : 'hip';
        document.getElementById('gunWorldFwd').value = gunModel[prefix + 'WorldForward'];
        document.getElementById('gunWorldFwd-value').innerText = gunModel[prefix + 'WorldForward'];
        document.getElementById('gunWorldRight').value = gunModel[prefix + 'WorldRight'];
        document.getElementById('gunWorldRight-value').innerText = gunModel[prefix + 'WorldRight'];
        document.getElementById('gunWorldDown').value = gunModel[prefix + 'WorldDown'];
        document.getElementById('gunWorldDown-value').innerText = gunModel[prefix + 'WorldDown'];
    }

    // Unified function to set edit mode for both Gun and Barrel tabs
    function setEditMode(mode) {
        editMode = mode;
        var isAds = mode === 'ads';
        var activeColor = '#4CAF50';
        var inactiveColor = '#555';
        var labelColor = isAds ? '#4CAF50' : '#ff9800';
        var labelText = isAds ? '[Editing ADS]' : '[Editing Hip]';

        // Update Gun Tab buttons
        document.getElementById('editADS').style.background = isAds ? activeColor : inactiveColor;
        document.getElementById('editHip').style.background = isAds ? inactiveColor : activeColor;
        document.getElementById('editModeLabel').innerText = labelText;
        document.getElementById('editModeLabel').style.color = labelColor;

        // Update Barrel Tab buttons
        document.getElementById('barrelEditADS').style.background = isAds ? activeColor : inactiveColor;
        document.getElementById('barrelEditHip').style.background = isAds ? inactiveColor : activeColor;
        document.getElementById('barrelEditModeLabel').innerText = labelText;
        document.getElementById('barrelEditModeLabel').style.color = labelColor;

        // Update sliders for all tabs
        updateGunSliders();
        updateBarrelSliders();
        updateWorldOffsetSliders();
    }

    // Gun Tab edit mode buttons
    document.getElementById('editADS').addEventListener('click', function() {
        setEditMode('ads');
    });
    document.getElementById('editHip').addEventListener('click', function() {
        setEditMode('hip');
    });

    // Gun viewmodel sliders - update based on current edit mode
    document.getElementById('gunX').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsOffsetX = val;
        else gunModel.hipOffsetX = val;
        document.getElementById('gunX-value').innerText = val;
    });
    document.getElementById('gunY').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsOffsetY = val;
        else gunModel.hipOffsetY = val;
        document.getElementById('gunY-value').innerText = val;
    });
    document.getElementById('gunZ').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsOffsetZ = val;
        else gunModel.hipOffsetZ = val;
        document.getElementById('gunZ-value').innerText = val;
    });
    document.getElementById('gunScale').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsScale = val;
        else gunModel.hipScale = val;
        document.getElementById('gunScale-value').innerText = val;
    });
    document.getElementById('gunRotX').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsRotationX = val;
        else gunModel.hipRotationX = val;
        document.getElementById('gunRotX-value').innerText = val;
    });
    document.getElementById('gunRotY').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsRotationY = val;
        else gunModel.hipRotationY = val;
        document.getElementById('gunRotY-value').innerText = val;
    });
    document.getElementById('gunRotZ').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsRotationZ = val;
        else gunModel.hipRotationZ = val;
        document.getElementById('gunRotZ-value').innerText = val;
    });

    // Initialize sliders with ADS values
    updateGunSliders();
    updateBarrelSliders();
    updateWorldOffsetSliders();

    // Barrel Tab edit mode buttons (use shared setEditMode)
    document.getElementById('barrelEditADS').addEventListener('click', function() {
        setEditMode('ads');
    });
    document.getElementById('barrelEditHip').addEventListener('click', function() {
        setEditMode('hip');
    });

    // Barrel yaw slider - update based on current edit mode
    document.getElementById('barrelYaw').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsBarrelYaw = val;
        else gunModel.hipBarrelYaw = val;
        document.getElementById('barrelYaw-value').innerText = val;
    });

    // Barrel position sliders - update based on current edit mode
    document.getElementById('barrelX').addEventListener('input', function(e){
        var val = parseFloat(e.target.value);
        if (editMode === 'ads') gunModel.adsBarrelX = val;
        else gunModel.hipBarrelX = val;
        document.getElementById('barrelX-value').innerText = val.toFixed(2);
    });
    document.getElementById('barrelY').addEventListener('input', function(e){
        var val = parseFloat(e.target.value);
        if (editMode === 'ads') gunModel.adsBarrelY = val;
        else gunModel.hipBarrelY = val;
        document.getElementById('barrelY-value').innerText = val.toFixed(2);
    });
    document.getElementById('barrelZ').addEventListener('input', function(e){
        var val = parseFloat(e.target.value);
        if (editMode === 'ads') gunModel.adsBarrelZ = val;
        else gunModel.hipBarrelZ = val;
        document.getElementById('barrelZ-value').innerText = val.toFixed(2);
    });

    // Gun world offset sliders - update based on current edit mode
    document.getElementById('gunWorldFwd').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsWorldForward = val;
        else gunModel.hipWorldForward = val;
        document.getElementById('gunWorldFwd-value').innerText = val;
    });
    document.getElementById('gunWorldRight').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsWorldRight = val;
        else gunModel.hipWorldRight = val;
        document.getElementById('gunWorldRight-value').innerText = val;
    });
    document.getElementById('gunWorldDown').addEventListener('input', function(e){
        var val = parseInt(e.target.value);
        if (editMode === 'ads') gunModel.adsWorldDown = val;
        else gunModel.hipWorldDown = val;
        document.getElementById('gunWorldDown-value').innerText = val;
    });

    // Bullet size slider
    document.getElementById('bulletSize').addEventListener('input', function(e){
        bulletSize = parseFloat(e.target.value);
        document.getElementById('bulletSize-value').innerText = bulletSize;
    });

    // Barrel distance slider
    document.getElementById('barrelDistance').addEventListener('input', function(e){
        gunModel.barrelDistance = parseInt(e.target.value);
        document.getElementById('barrelDistance-value').innerText = gunModel.barrelDistance;
    });

    // Hit Detection sliders
    document.getElementById('hitscanDist').addEventListener('input', function(e){
        hitscanDistance = parseInt(e.target.value);
        document.getElementById('hitscanDist-value').innerText = hitscanDistance;
    });
    document.getElementById('ccdMaxDist').addEventListener('input', function(e){
        ccdMaxDistance = parseInt(e.target.value);
        document.getElementById('ccdMaxDist-value').innerText = ccdMaxDistance;
    });
    document.getElementById('showHitRanges').addEventListener('change', function(e){
        showHitRanges = e.target.checked;
    });

    // GMD (Gun Mechanics Debug) controls
    document.getElementById('showGMD').addEventListener('change', function(e){
        showGMD = e.target.checked;
    });
    document.getElementById('showTestTarget').addEventListener('change', function(e){
        testTarget.enabled = e.target.checked;
    });
    document.getElementById('showMinimaps').addEventListener('change', function(e){
        showMinimaps = e.target.checked;
    });
    document.getElementById('targetDistance').addEventListener('input', function(e){
        var dist = parseInt(e.target.value);
        document.getElementById('targetDistance-value').innerText = dist;
        // Reposition target at new distance
        var fx = -Math.sin(camera.angle);
        var fy = -Math.cos(camera.angle);
        testTarget.x = camera.x + fx * dist;
        testTarget.y = camera.y + fy * dist;
        testTarget.z = camera.height;
    });
    document.getElementById('targetRadius').addEventListener('input', function(e){
        testTarget.radius = parseFloat(e.target.value);
        document.getElementById('targetRadius-value').innerText = testTarget.radius.toFixed(1);
    });
    document.getElementById('resetHitCount').addEventListener('click', function(){
        testTarget.hits = 0;
        testTarget.misses = 0;
        testTarget.bulletHitPos = null;
    });

    // UI Scale sliders
    document.getElementById('uiScaleAll').addEventListener('input', function(e){
        var scale = parseFloat(e.target.value);
        uiScale.all = scale;
        document.getElementById('uiScaleAll-value').innerText = scale.toFixed(1);
        // Update all individual scales
        uiScale.crosshair = scale;
        uiScale.healthbar = scale;
        uiScale.jumpbar = scale;
        uiScale.minimap = scale;
        uiScale.weaponUI = scale;
        // Update slider displays
        document.getElementById('uiScaleCrosshair').value = scale;
        document.getElementById('uiScaleCrosshair-value').innerText = scale.toFixed(1);
        document.getElementById('uiScaleHealthbar').value = scale;
        document.getElementById('uiScaleHealthbar-value').innerText = scale.toFixed(1);
        document.getElementById('uiScaleJumpbar').value = scale;
        document.getElementById('uiScaleJumpbar-value').innerText = scale.toFixed(1);
        document.getElementById('uiScaleMinimap').value = scale;
        document.getElementById('uiScaleMinimap-value').innerText = scale.toFixed(1);
        document.getElementById('uiScaleWeaponUI').value = scale;
        document.getElementById('uiScaleWeaponUI-value').innerText = scale.toFixed(1);
        applyUIScales();
    });
    document.getElementById('uiScaleCrosshair').addEventListener('input', function(e){
        uiScale.crosshair = parseFloat(e.target.value);
        document.getElementById('uiScaleCrosshair-value').innerText = uiScale.crosshair.toFixed(1);
        applyUIScales();
    });
    document.getElementById('uiScaleHealthbar').addEventListener('input', function(e){
        uiScale.healthbar = parseFloat(e.target.value);
        document.getElementById('uiScaleHealthbar-value').innerText = uiScale.healthbar.toFixed(1);
        applyUIScales();
    });
    document.getElementById('uiScaleJumpbar').addEventListener('input', function(e){
        uiScale.jumpbar = parseFloat(e.target.value);
        document.getElementById('uiScaleJumpbar-value').innerText = uiScale.jumpbar.toFixed(1);
        applyUIScales();
    });
    document.getElementById('uiScaleMinimap').addEventListener('input', function(e){
        uiScale.minimap = parseFloat(e.target.value);
        document.getElementById('uiScaleMinimap-value').innerText = uiScale.minimap.toFixed(1);
        applyUIScales();
    });
    document.getElementById('minimapZoomRange').addEventListener('input', function(e){
        minimapZoomRange = parseInt(e.target.value);
        document.getElementById('minimapZoomRange-value').innerText = minimapZoomRange;
    });
    document.getElementById('sideViewZoomRange').addEventListener('input', function(e){
        sideViewZoomRange = parseInt(e.target.value);
        document.getElementById('sideViewZoomRange-value').innerText = sideViewZoomRange;
    });
    document.getElementById('uiScaleWeaponUI').addEventListener('input', function(e){
        uiScale.weaponUI = parseFloat(e.target.value);
        document.getElementById('uiScaleWeaponUI-value').innerText = uiScale.weaponUI.toFixed(1);
        applyUIScales();
    });

    // Save/Reset functionality
    var savedSettings = null;

    function getAllSettings() {
        return {
            // Camera
            fov: parseInt(document.getElementById('fov').value),
            pitchOffset: parseInt(document.getElementById('pitchOffset').value),
            targetFPS: parseInt(document.getElementById('targetFPS').value),
            // Player
            playerHeight: parseInt(document.getElementById('playerHeight').value),
            normalHeight: parseInt(document.getElementById('normalHeight').value),
            crouchHeight: parseInt(document.getElementById('crouchHeight').value),
            jumpMin: parseInt(document.getElementById('jumpMin').value),
            jumpMax: parseInt(document.getElementById('jumpMax').value),
            walkSpeed: parseFloat(document.getElementById('walkSpeed').value),
            sprintMultiplier: parseFloat(document.getElementById('sprintMultiplier').value),
            // Bullet
            bulletSize: parseFloat(document.getElementById('bulletSize').value),
            barrelDistance: parseInt(document.getElementById('barrelDistance').value),
            // Gun (save ADS values as legacy gunX/Y/Z for backward compatibility)
            gunX: gunModel.adsOffsetX,
            gunY: gunModel.adsOffsetY,
            gunZ: gunModel.adsOffsetZ,
            gunScale: gunModel.adsScale,
            gunRotX: gunModel.adsRotationX,
            gunRotY: gunModel.adsRotationY,
            gunRotZ: gunModel.adsRotationZ,
            // Barrel (save ADS values as legacy barrelX/Y/Z for backward compatibility)
            barrelX: gunModel.adsBarrelX,
            barrelY: gunModel.adsBarrelY,
            barrelZ: gunModel.adsBarrelZ,
            barrelYaw: gunModel.adsBarrelYaw,
            // ADS barrel settings
            adsBarrelX: gunModel.adsBarrelX,
            adsBarrelY: gunModel.adsBarrelY,
            adsBarrelZ: gunModel.adsBarrelZ,
            adsBarrelYaw: gunModel.adsBarrelYaw,
            // Hip barrel settings
            hipBarrelX: gunModel.hipBarrelX,
            hipBarrelY: gunModel.hipBarrelY,
            hipBarrelZ: gunModel.hipBarrelZ,
            hipBarrelYaw: gunModel.hipBarrelYaw,
            // World offset (save ADS values as legacy for backward compatibility)
            gunWorldFwd: gunModel.adsWorldForward,
            gunWorldRight: gunModel.adsWorldRight,
            gunWorldDown: gunModel.adsWorldDown,
            // ADS world offset settings
            adsWorldForward: gunModel.adsWorldForward,
            adsWorldRight: gunModel.adsWorldRight,
            adsWorldDown: gunModel.adsWorldDown,
            // Hip world offset settings
            hipWorldForward: gunModel.hipWorldForward,
            hipWorldRight: gunModel.hipWorldRight,
            hipWorldDown: gunModel.hipWorldDown,
            // UI Scale
            uiScaleAll: parseFloat(document.getElementById('uiScaleAll').value),
            uiScaleCrosshair: parseFloat(document.getElementById('uiScaleCrosshair').value),
            uiScaleHealthbar: parseFloat(document.getElementById('uiScaleHealthbar').value),
            uiScaleJumpbar: parseFloat(document.getElementById('uiScaleJumpbar').value),
            uiScaleMinimap: parseFloat(document.getElementById('uiScaleMinimap').value),
            minimapZoomRange: parseInt(document.getElementById('minimapZoomRange').value),
            sideViewZoomRange: parseInt(document.getElementById('sideViewZoomRange').value),
            uiScaleWeaponUI: parseFloat(document.getElementById('uiScaleWeaponUI').value),
            // ADS position settings
            adsOffsetX: gunModel.adsOffsetX,
            adsOffsetY: gunModel.adsOffsetY,
            adsOffsetZ: gunModel.adsOffsetZ,
            adsScale: gunModel.adsScale,
            adsRotationX: gunModel.adsRotationX,
            adsRotationY: gunModel.adsRotationY,
            adsRotationZ: gunModel.adsRotationZ,
            // Hip fire position settings
            hipOffsetX: gunModel.hipOffsetX,
            hipOffsetY: gunModel.hipOffsetY,
            hipOffsetZ: gunModel.hipOffsetZ,
            hipScale: gunModel.hipScale,
            hipRotationX: gunModel.hipRotationX,
            hipRotationY: gunModel.hipRotationY,
            hipRotationZ: gunModel.hipRotationZ,
            // Scope mode
            scopeMode: scopeMode,
            // Debug/GMD settings
            showHitRanges: document.getElementById('showHitRanges').checked,
            showGMD: document.getElementById('showGMD').checked,
            showMinimaps: document.getElementById('showMinimaps').checked,
            showTestTarget: document.getElementById('showTestTarget').checked,
            targetDistance: parseInt(document.getElementById('targetDistance').value),
            targetRadius: parseFloat(document.getElementById('targetRadius').value)
        };
    }

    function applySettings(s) {
        // Camera
        document.getElementById('fov').value = s.fov;
        document.getElementById('fov-value').innerText = s.fov;
        camera.baseFocalLength = s.fov;
        camera.focalLength = s.fov;
        document.getElementById('pitchOffset').value = s.pitchOffset;
        document.getElementById('pitchOffset-value').innerText = s.pitchOffset;
        pitchOffset = s.pitchOffset;
        document.getElementById('targetFPS').value = s.targetFPS;
        document.getElementById('targetFPS-value').innerText = s.targetFPS;
        targetFPS = s.targetFPS;
        frameDuration = 1000 / targetFPS;

        // Player
        document.getElementById('playerHeight').value = s.playerHeight;
        document.getElementById('playerHeight-value').innerText = s.playerHeight;
        playerHeightOffset = s.playerHeight;
        document.getElementById('normalHeight').value = s.normalHeight;
        document.getElementById('normalHeight-value').innerText = s.normalHeight;
        player.normalHeight = s.normalHeight;
        document.getElementById('crouchHeight').value = s.crouchHeight;
        document.getElementById('crouchHeight-value').innerText = s.crouchHeight;
        player.crouchHeight = s.crouchHeight;
        document.getElementById('jumpMin').value = s.jumpMin;
        document.getElementById('jumpMin-value').innerText = s.jumpMin;
        player.jumpMinStrength = s.jumpMin;
        document.getElementById('jumpMax').value = s.jumpMax;
        document.getElementById('jumpMax-value').innerText = s.jumpMax;
        player.jumpMaxStrength = s.jumpMax;

        // Walk speed and sprint multiplier
        if (s.walkSpeed !== undefined) {
            document.getElementById('walkSpeed').value = s.walkSpeed;
            document.getElementById('walkSpeed-value').innerText = s.walkSpeed.toFixed(1);
            player.moveSpeed = s.walkSpeed;
        }
        if (s.sprintMultiplier !== undefined) {
            document.getElementById('sprintMultiplier').value = s.sprintMultiplier;
            document.getElementById('sprintMultiplier-value').innerText = s.sprintMultiplier.toFixed(1);
            player.sprintMultiplier = s.sprintMultiplier;
        }

        // Bullet
        document.getElementById('bulletSize').value = s.bulletSize;
        document.getElementById('bulletSize-value').innerText = s.bulletSize;
        bulletSize = s.bulletSize;
        document.getElementById('barrelDistance').value = s.barrelDistance;
        document.getElementById('barrelDistance-value').innerText = s.barrelDistance;
        gunModel.barrelDistance = s.barrelDistance;

        // Gun - Legacy values (gunX, gunY, etc.) are applied to ADS settings
        // since the interpolation system overwrites offsetX/Y/Z every frame
        // Only apply legacy values if new ADS settings don't exist in save
        if (s.adsOffsetX === undefined) {
            // Old save format - apply to ADS settings (user saved in ADS mode)
            gunModel.adsOffsetX = s.gunX;
            gunModel.adsOffsetY = s.gunY;
            gunModel.adsOffsetZ = s.gunZ;
            gunModel.adsScale = s.gunScale;
            gunModel.adsRotationX = s.gunRotX;
            gunModel.adsRotationY = s.gunRotY;
            gunModel.adsRotationZ = s.gunRotZ;
            // Also set hip to same values as reasonable default
            gunModel.hipOffsetX = s.gunX;
            gunModel.hipOffsetY = s.gunY;
            gunModel.hipOffsetZ = s.gunZ;
            gunModel.hipScale = s.gunScale;
            gunModel.hipRotationX = s.gunRotX;
            gunModel.hipRotationY = s.gunRotY;
            gunModel.hipRotationZ = s.gunRotZ;
        }
        // Update slider displays (they show based on current edit mode)
        document.getElementById('gunX').value = s.gunX;
        document.getElementById('gunX-value').innerText = s.gunX;
        document.getElementById('gunY').value = s.gunY;
        document.getElementById('gunY-value').innerText = s.gunY;
        document.getElementById('gunZ').value = s.gunZ;
        document.getElementById('gunZ-value').innerText = s.gunZ;
        document.getElementById('gunScale').value = s.gunScale;
        document.getElementById('gunScale-value').innerText = s.gunScale;
        document.getElementById('gunRotX').value = s.gunRotX;
        document.getElementById('gunRotX-value').innerText = s.gunRotX;
        document.getElementById('gunRotY').value = s.gunRotY;
        document.getElementById('gunRotY-value').innerText = s.gunRotY;
        document.getElementById('gunRotZ').value = s.gunRotZ;
        document.getElementById('gunRotZ-value').innerText = s.gunRotZ;
        // ADS barrel settings (new format)
        if (s.adsBarrelX !== undefined) {
            gunModel.adsBarrelX = s.adsBarrelX;
            gunModel.adsBarrelY = s.adsBarrelY;
            gunModel.adsBarrelZ = s.adsBarrelZ;
            gunModel.adsBarrelYaw = s.adsBarrelYaw !== undefined ? s.adsBarrelYaw : 0;
        } else {
            // Old save format - apply legacy barrel values to ADS settings
            gunModel.adsBarrelX = s.barrelX;
            gunModel.adsBarrelY = s.barrelY;
            gunModel.adsBarrelZ = s.barrelZ;
            gunModel.adsBarrelYaw = s.barrelYaw !== undefined ? s.barrelYaw : 0;
        }

        // Hip barrel settings (new format)
        if (s.hipBarrelX !== undefined) {
            gunModel.hipBarrelX = s.hipBarrelX;
            gunModel.hipBarrelY = s.hipBarrelY;
            gunModel.hipBarrelZ = s.hipBarrelZ;
            gunModel.hipBarrelYaw = s.hipBarrelYaw !== undefined ? s.hipBarrelYaw : 0;
        } else {
            // Old save format - use same values as ADS for hip (user can adjust)
            gunModel.hipBarrelX = gunModel.adsBarrelX;
            gunModel.hipBarrelY = gunModel.adsBarrelY;
            gunModel.hipBarrelZ = gunModel.adsBarrelZ;
            gunModel.hipBarrelYaw = gunModel.adsBarrelYaw;
        }

        // Update sliders to show ADS values (default edit mode)
        document.getElementById('barrelX').value = gunModel.adsBarrelX;
        document.getElementById('barrelX-value').innerText = gunModel.adsBarrelX.toFixed(2);
        document.getElementById('barrelY').value = gunModel.adsBarrelY;
        document.getElementById('barrelY-value').innerText = gunModel.adsBarrelY.toFixed(2);
        document.getElementById('barrelZ').value = gunModel.adsBarrelZ;
        document.getElementById('barrelZ-value').innerText = gunModel.adsBarrelZ.toFixed(2);
        document.getElementById('barrelYaw').value = gunModel.adsBarrelYaw;
        document.getElementById('barrelYaw-value').innerText = gunModel.adsBarrelYaw;

        // Gun world offset - ADS settings (new format)
        if (s.adsWorldForward !== undefined) {
            gunModel.adsWorldForward = s.adsWorldForward;
            gunModel.adsWorldRight = s.adsWorldRight;
            gunModel.adsWorldDown = s.adsWorldDown;
        } else if (s.gunWorldFwd !== undefined) {
            // Old save format - apply legacy values to ADS
            gunModel.adsWorldForward = s.gunWorldFwd;
            gunModel.adsWorldRight = s.gunWorldRight;
            gunModel.adsWorldDown = s.gunWorldDown;
        }

        // Gun world offset - Hip settings (new format)
        if (s.hipWorldForward !== undefined) {
            gunModel.hipWorldForward = s.hipWorldForward;
            gunModel.hipWorldRight = s.hipWorldRight;
            gunModel.hipWorldDown = s.hipWorldDown;
        } else if (s.gunWorldFwd !== undefined) {
            // Old save format - use same values as ADS for hip
            gunModel.hipWorldForward = gunModel.adsWorldForward;
            gunModel.hipWorldRight = gunModel.adsWorldRight;
            gunModel.hipWorldDown = gunModel.adsWorldDown;
        }

        // Update sliders to show ADS values (default edit mode)
        document.getElementById('gunWorldFwd').value = gunModel.adsWorldForward;
        document.getElementById('gunWorldFwd-value').innerText = gunModel.adsWorldForward;
        document.getElementById('gunWorldRight').value = gunModel.adsWorldRight;
        document.getElementById('gunWorldRight-value').innerText = gunModel.adsWorldRight;
        document.getElementById('gunWorldDown').value = gunModel.adsWorldDown;
        document.getElementById('gunWorldDown-value').innerText = gunModel.adsWorldDown;

        // UI Scale
        if (s.uiScaleAll !== undefined) {
            document.getElementById('uiScaleAll').value = s.uiScaleAll;
            document.getElementById('uiScaleAll-value').innerText = s.uiScaleAll.toFixed(1);
            uiScale.all = s.uiScaleAll;
        }
        if (s.uiScaleCrosshair !== undefined) {
            document.getElementById('uiScaleCrosshair').value = s.uiScaleCrosshair;
            document.getElementById('uiScaleCrosshair-value').innerText = s.uiScaleCrosshair.toFixed(1);
            uiScale.crosshair = s.uiScaleCrosshair;
        }
        if (s.uiScaleHealthbar !== undefined) {
            document.getElementById('uiScaleHealthbar').value = s.uiScaleHealthbar;
            document.getElementById('uiScaleHealthbar-value').innerText = s.uiScaleHealthbar.toFixed(1);
            uiScale.healthbar = s.uiScaleHealthbar;
        }
        if (s.uiScaleJumpbar !== undefined) {
            document.getElementById('uiScaleJumpbar').value = s.uiScaleJumpbar;
            document.getElementById('uiScaleJumpbar-value').innerText = s.uiScaleJumpbar.toFixed(1);
            uiScale.jumpbar = s.uiScaleJumpbar;
        }
        if (s.uiScaleMinimap !== undefined) {
            document.getElementById('uiScaleMinimap').value = s.uiScaleMinimap;
            document.getElementById('uiScaleMinimap-value').innerText = s.uiScaleMinimap.toFixed(1);
            uiScale.minimap = s.uiScaleMinimap;
        }
        if (s.minimapZoomRange !== undefined) {
            document.getElementById('minimapZoomRange').value = s.minimapZoomRange;
            document.getElementById('minimapZoomRange-value').innerText = s.minimapZoomRange;
            minimapZoomRange = s.minimapZoomRange;
        }
        if (s.sideViewZoomRange !== undefined) {
            document.getElementById('sideViewZoomRange').value = s.sideViewZoomRange;
            document.getElementById('sideViewZoomRange-value').innerText = s.sideViewZoomRange;
            sideViewZoomRange = s.sideViewZoomRange;
        }
        if (s.uiScaleWeaponUI !== undefined) {
            document.getElementById('uiScaleWeaponUI').value = s.uiScaleWeaponUI;
            document.getElementById('uiScaleWeaponUI-value').innerText = s.uiScaleWeaponUI.toFixed(1);
            uiScale.weaponUI = s.uiScaleWeaponUI;
        }
        // Apply the UI scales
        applyUIScales();

        // ADS position settings (new format)
        if (s.adsOffsetX !== undefined) gunModel.adsOffsetX = s.adsOffsetX;
        if (s.adsOffsetY !== undefined) gunModel.adsOffsetY = s.adsOffsetY;
        if (s.adsOffsetZ !== undefined) gunModel.adsOffsetZ = s.adsOffsetZ;
        if (s.adsScale !== undefined) gunModel.adsScale = s.adsScale;
        if (s.adsRotationX !== undefined) gunModel.adsRotationX = s.adsRotationX;
        if (s.adsRotationY !== undefined) gunModel.adsRotationY = s.adsRotationY;
        if (s.adsRotationZ !== undefined) gunModel.adsRotationZ = s.adsRotationZ;

        // Hip fire position settings (new format)
        if (s.hipOffsetX !== undefined) gunModel.hipOffsetX = s.hipOffsetX;
        if (s.hipOffsetY !== undefined) gunModel.hipOffsetY = s.hipOffsetY;
        if (s.hipOffsetZ !== undefined) gunModel.hipOffsetZ = s.hipOffsetZ;
        if (s.hipScale !== undefined) gunModel.hipScale = s.hipScale;
        if (s.hipRotationX !== undefined) gunModel.hipRotationX = s.hipRotationX;
        if (s.hipRotationY !== undefined) gunModel.hipRotationY = s.hipRotationY;
        if (s.hipRotationZ !== undefined) gunModel.hipRotationZ = s.hipRotationZ;

        // Migration fix: if new ADS values are defaults (0) but old gunRot values exist,
        // use the old values (save was made with default ADS values before user configured them)
        if (s.adsRotationY === 0 && s.gunRotY !== 0) {
            gunModel.adsRotationX = s.gunRotX;
            gunModel.adsRotationY = s.gunRotY;
            gunModel.adsRotationZ = s.gunRotZ;
            gunModel.hipRotationX = s.gunRotX;
            gunModel.hipRotationY = s.gunRotY;
            gunModel.hipRotationZ = s.gunRotZ;
        }
        if (s.adsOffsetX === 0 && s.gunX !== 0) {
            gunModel.adsOffsetX = s.gunX;
            gunModel.adsOffsetY = s.gunY;
            gunModel.adsOffsetZ = s.gunZ;
            gunModel.adsScale = s.gunScale;
        }
        if (s.hipOffsetX === 100 && s.gunX !== 100) {
            // Hip defaults were 100, if gunX is different, use it
            gunModel.hipOffsetX = s.gunX;
            gunModel.hipOffsetY = s.gunY;
            gunModel.hipOffsetZ = s.gunZ;
            gunModel.hipScale = s.gunScale;
        }

        // Update gun sliders to reflect current edit mode
        if (typeof updateGunSliders === 'function') {
            updateGunSliders();
        }

        // Scope mode
        if (s.scopeMode !== undefined) {
            setScopeMode(s.scopeMode);
        }

        // Debug/GMD settings
        if (s.showHitRanges !== undefined) {
            document.getElementById('showHitRanges').checked = s.showHitRanges;
            showHitRanges = s.showHitRanges;
        }
        if (s.showGMD !== undefined) {
            document.getElementById('showGMD').checked = s.showGMD;
            showGMD = s.showGMD;
        }
        if (s.showMinimaps !== undefined) {
            document.getElementById('showMinimaps').checked = s.showMinimaps;
            showMinimaps = s.showMinimaps;
        }
        if (s.showTestTarget !== undefined) {
            document.getElementById('showTestTarget').checked = s.showTestTarget;
            testTarget.enabled = s.showTestTarget;
        }
        if (s.targetDistance !== undefined) {
            document.getElementById('targetDistance').value = s.targetDistance;
            document.getElementById('targetDistance-value').innerText = s.targetDistance;
            testTarget.distance = s.targetDistance;
        }
        if (s.targetRadius !== undefined) {
            document.getElementById('targetRadius').value = s.targetRadius;
            document.getElementById('targetRadius-value').innerText = s.targetRadius.toFixed(1);
            testTarget.radius = s.targetRadius;
        }
    }

    // Save button - saves to localStorage AND copies JSON to clipboard
    document.getElementById('saveSettings').addEventListener('click', function() {
        savedSettings = getAllSettings();
        localStorage.setItem('voxelSpaceSettings', JSON.stringify(savedSettings));

        // Also export JSON for file update
        var exported = ConfigLoader.copyToClipboard(gunModel);
        console.log('Settings saved to localStorage AND copied to clipboard as JSON');
        console.log('To persist: paste clipboard content into data/settings.json and data/gunModel.json');

        this.textContent = 'Saved + Copied!';
        setTimeout(() => this.textContent = 'Save', 2000);
    });

    // Reset button - restores last saved settings
    document.getElementById('resetSettings').addEventListener('click', function() {
        if (savedSettings) {
            applySettings(savedSettings);
            this.textContent = 'Reset!';
            setTimeout(() => this.textContent = 'Reset', 1000);
        }
    });

    // Load settings on startup - localStorage first (user saves), then JSON as fallback
    ConfigLoader.loadAll().then(function(jsonLoaded) {
        // Check localStorage first - user's saved settings take priority
        var stored = localStorage.getItem('voxelSpaceSettings');
        if (stored) {
            try {
                savedSettings = JSON.parse(stored);
                console.log('Loading saved settings from localStorage:', savedSettings);
                applySettings(savedSettings);
                console.log('Applied all settings from localStorage');
                // Also apply weapons from JSON if available
                if (jsonLoaded) {
                    ConfigLoader.applyWeapons();
                }
                return; // Don't apply JSON defaults, user has saved settings
            } catch(e) {
                console.log('Could not load saved settings:', e);
            }
        }

        // No localStorage - use JSON files as defaults
        if (jsonLoaded && ConfigLoader.gunModel) {
            // Apply JSON config (defaults)
            ConfigLoader.applyGunModel(gunModel);
            ConfigLoader.applyWeapons();
            // Apply minimap zoom from JSON
            if (ConfigLoader.settings && ConfigLoader.settings.minimap) {
                if (ConfigLoader.settings.minimap.zoomRange !== undefined) {
                    minimapZoomRange = ConfigLoader.settings.minimap.zoomRange;
                    document.getElementById('minimapZoomRange').value = minimapZoomRange;
                    document.getElementById('minimapZoomRange-value').innerText = minimapZoomRange;
                }
                if (ConfigLoader.settings.minimap.sideViewZoomRange !== undefined) {
                    sideViewZoomRange = ConfigLoader.settings.minimap.sideViewZoomRange;
                    document.getElementById('sideViewZoomRange').value = sideViewZoomRange;
                    document.getElementById('sideViewZoomRange-value').innerText = sideViewZoomRange;
                }
            }
            // Apply debug settings from JSON
            if (ConfigLoader.settings && ConfigLoader.settings.debug) {
                var dbg = ConfigLoader.settings.debug;
                if (dbg.showHitRanges !== undefined) {
                    showHitRanges = dbg.showHitRanges;
                    document.getElementById('showHitRanges').checked = showHitRanges;
                }
                if (dbg.showGMD !== undefined) {
                    showGMD = dbg.showGMD;
                    document.getElementById('showGMD').checked = showGMD;
                }
                if (dbg.showTestTarget !== undefined) {
                    testTarget.enabled = dbg.showTestTarget;
                    document.getElementById('showTestTarget').checked = testTarget.enabled;
                }
                if (dbg.targetDistance !== undefined) {
                    testTarget.distance = dbg.targetDistance;
                    document.getElementById('targetDistance').value = testTarget.distance;
                    document.getElementById('targetDistance-value').innerText = testTarget.distance;
                }
                if (dbg.targetRadius !== undefined) {
                    testTarget.radius = dbg.targetRadius;
                    document.getElementById('targetRadius').value = testTarget.radius;
                    document.getElementById('targetRadius-value').innerText = testTarget.radius.toFixed(1);
                }
            }
            console.log('Settings loaded from data/*.json files (no localStorage found)');
        }
    });

    // Debug: expose function to clear saved settings via console
    window.clearVoxelSettings = function() {
        localStorage.removeItem('voxelSpaceSettings');
        console.log('Saved settings cleared. Refresh to use defaults from JSON.');
    };

    // Debug: expose function to reload JSON configs
    window.reloadJsonConfigs = function() {
        ConfigLoader.loadAll().then(function(loaded) {
            if (loaded) {
                ConfigLoader.applyGunModel(gunModel);
                ConfigLoader.applyWeapons();
                console.log('JSON configs reloaded and applied');
            }
        });
    };
    console.log('Tips:');
    console.log('  - clearVoxelSettings() to reset localStorage');
    console.log('  - reloadJsonConfigs() to reload from data/*.json');
}
// ===============================
// Gamepad Support
function pollGamepad(){
    var gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
    var gp = null;

    // Find first connected gamepad
    for(var i = 0; i < gamepads.length; i++){
        if(gamepads[i] && gamepads[i].connected){
            gp = gamepads[i];
            break;
        }
    }

    if(!gp){
        gamepad.connected = false;
        input.moveX = 0;
        input.moveY = 0;
        input.lookX = 0;
        input.lookY = 0;
        input.gpShoot = false;
        input.gpAim = false;
        input.gpCrouch = false;
        input.gpSprint = false;
        input.gpReload = false;
        input.gpJumpHeld = false;
        return;
    }

    gamepad.connected = true;
    var dz = gamepad.deadzone;

    // Apply deadzone to axes
    function applyDeadzone(val){
        if(Math.abs(val) < dz) return 0;
        return (val - Math.sign(val) * dz) / (1 - dz);
    }

    // Movement (Left Stick)
    input.moveX = applyDeadzone(gp.axes[gamepad.axes.moveX] || 0);
    input.moveY = applyDeadzone(gp.axes[gamepad.axes.moveY] || 0);

    // Look (Right Stick)
    input.lookX = applyDeadzone(gp.axes[gamepad.axes.lookX] || 0);
    input.lookY = applyDeadzone(gp.axes[gamepad.axes.lookY] || 0);

    // Buttons - read directly from gamepad
    var btn = gp.buttons;

    // Helper to check if a gamepad button is pressed
    function isPressed(btnIndex){
        return btn[btnIndex] && (btn[btnIndex].pressed || btn[btnIndex].value > 0.5);
    }

    // Read current gamepad button states
    var gpJump = isPressed(gamepad.buttons.jump);
    var gpCrouch = isPressed(gamepad.buttons.crouch);
    var gpReload = isPressed(gamepad.buttons.reload);
    var gpSprint = isPressed(gamepad.buttons.sprint) || isPressed(gamepad.buttons.sprintAlt);
    var gpShoot = isPressed(gamepad.buttons.shoot);
    var gpAim = isPressed(gamepad.buttons.aim);

    // Jump - track held state for charged jump (jump on RELEASE)
    input.gpJumpHeld = gpJump;

    // These are held buttons - directly set state from gamepad
    // (keyboard state is separate and handled by keyup/keydown)
    input.gpCrouch = gpCrouch;
    input.gpSprint = gpSprint;
    input.gpShoot = gpShoot;
    input.gpReload = gpReload;

    // ADS toggle for gamepad (edge detection: toggle on press)
    if(gpAim && !input.prevGpAim){
        input.aimToggled = !input.aimToggled;
    }
    input.prevGpAim = gpAim;

    // Start button - toggle debug UI (edge detection: only on press)
    var gpStart = isPressed(gamepad.buttons.start);
    if(gpStart && !gamepad.prevStart){
        toggleDebugUI();
    }
    gamepad.prevStart = gpStart;

    // Y button - swap weapons (edge detection)
    var gpSwap = isPressed(gamepad.buttons.swapWeapon);
    input.gpSwapWeapon = gpSwap && !prevSwapButton;
    prevSwapButton = gpSwap;

    // X button for pickup when near a weapon
    input.gpPickupWeapon = isPressed(gamepad.buttons.pickup);
}

function toggleDebugUI(){
    debugUIVisible = !debugUIVisible;
    var display = debugUIVisible ? 'block' : 'none';
    // Hide/show non-gaming UI elements
    var debugElements = ['controls', 'fps', 'info', 'lastbulletpos', 'lastbulletscreen', 'lastbulletdestroyedpos', 'lastbulletdestroyedreason', 'playerposition', 'playerrotation'];
    debugElements.forEach(function(id){
        var el = document.getElementById(id);
        if(el) el.style.display = display;
    });
}

// ===============================
// Controls
function DetectKeysDown(e){switch(e.keyCode){case 87:input.forward=true;break;case 83:input.backward=true;break;case 65:input.left=true;break;case 68:input.right=true;break;case 32:input.jump=true;break;case 16:input.sprint=true;break;case 67:input.crouch=true;break;case 82:input.reload=true;break;case 81:input.swapWeapon=true;break;case 69:input.pickupWeapon=true;break;case 90:var zoomPresets=[20,50,100,200,300];var idx=zoomPresets.indexOf(minimapZoomRange);minimapZoomRange=zoomPresets[(idx+1)%zoomPresets.length];document.getElementById('minimapZoomRange').value=minimapZoomRange;document.getElementById('minimapZoomRange-value').innerText=minimapZoomRange;var sidePresets=[20,50,100,200,300,500];var sidx=sidePresets.indexOf(sideViewZoomRange);sideViewZoomRange=sidePresets[(sidx+1)%sidePresets.length];document.getElementById('sideViewZoomRange').value=sideViewZoomRange;document.getElementById('sideViewZoomRange-value').innerText=sideViewZoomRange;break;case 84:positionTestTarget();break;case 71:testTarget.enabled=!testTarget.enabled;break;case 27:var ctrl=document.getElementById('controls');ctrl.style.display=ctrl.style.display==='none'?'block':'none';break;}if(!updaterunning){time=Date.now();Draw();}}
function DetectKeysUp(e){switch(e.keyCode){case 87:input.forward=false;break;case 83:input.backward=false;break;case 65:input.left=false;break;case 68:input.right=false;break;case 32:input.jump=false;break;case 16:input.sprint=false;break;case 67:input.crouch=false;break;case 82:input.reload=false;break;case 81:input.swapWeapon=false;break;case 69:input.pickupWeapon=false;break;}}
function DetectMouseDown(e){
    if(e.button===0) input.shoot=true;
    if(e.button===2) input.aimToggled = !input.aimToggled; // Right-click toggles ADS
}
function DetectMouseUp(e){
    if(e.button===0) input.shoot=false;
    // ADS is now toggle, no action on mouse up
}
function DetectMouseMove(e){camera.angle=(camera.angle-e.movementX*0.002)%(2*Math.PI);if(camera.angle<0)camera.angle+=2*Math.PI;camera.horizon=Math.max(-400,Math.min(600,camera.horizon-e.movementY*0.2));}
function DetectMouseWheel(e){
    // Only handle zoom when ADS with sniper scope
    var currentSlot = playerWeapons[currentWeaponIndex];
    var currentWeapon = weapons[currentSlot.type];
    if(input.aimToggled && currentWeapon.useScope && activeScope){
        e.preventDefault();
        activeScope.handleZoom(e.deltaY);
    }
}

// ===============================
Init();
</script>
</body>
</html>
